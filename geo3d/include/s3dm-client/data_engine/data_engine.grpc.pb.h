// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: data_engine/data_engine.proto
#ifndef GRPC_data_5fengine_2fdata_5fengine_2eproto__INCLUDED
#define GRPC_data_5fengine_2fdata_5fengine_2eproto__INCLUDED

#include "data_engine/data_engine.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace smart3dmap {
namespace v1 {

class DataEngine final {
 public:
  static constexpr char const* service_full_name() {
    return "smart3dmap.v1.DataEngine";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 查询支持的数据库服务器类型信息
    virtual ::grpc::Status ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::smart3dmap::v1::ListDBServerTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>> AsyncListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>>(AsyncListDBServerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>> PrepareAsyncListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>>(PrepareAsyncListDBServerTypesRaw(context, request, cq));
    }
    // 添加数据库服务器
    virtual ::grpc::Status CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::smart3dmap::v1::DBServer* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>> AsyncCreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>>(AsyncCreateDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>> PrepareAsyncCreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>>(PrepareAsyncCreateDatabaseServerRaw(context, request, cq));
    }
    // 获取可用的数据库服务器列表
    virtual ::grpc::Status ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::smart3dmap::v1::ListDatabaseServersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>> AsyncListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>>(AsyncListDatabaseServersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>> PrepareAsyncListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>>(PrepareAsyncListDatabaseServersRaw(context, request, cq));
    }
    // 获取指定的数据库服务器的详细信息。
    virtual ::grpc::Status GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::smart3dmap::v1::DBServer* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>> AsyncGetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>>(AsyncGetDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>> PrepareAsyncGetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>>(PrepareAsyncGetDatabaseServerRaw(context, request, cq));
    }
    // 修改指定的数据库服务器的信息。
    virtual ::grpc::Status UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>> AsyncUpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>>(AsyncUpdateDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>> PrepareAsyncUpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>>(PrepareAsyncUpdateDatabaseServerRaw(context, request, cq));
    }
    // 删除指定的数据库服务器。仅该数据库服务器没有关联任何数据库时才可被删除。
    virtual ::grpc::Status DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>> AsyncDeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>>(AsyncDeleteDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>> PrepareAsyncDeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>>(PrepareAsyncDeleteDatabaseServerRaw(context, request, cq));
    }
    // 查询业务数据库的分类信息
    virtual ::grpc::Status ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>> AsyncListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>>(AsyncListDatabaseAppTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>> PrepareAsyncListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>>(PrepareAsyncListDatabaseAppTypesRaw(context, request, cq));
    }
    // 创建业务数据库
    virtual ::grpc::Status CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::smart3dmap::v1::Database* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> AsyncCreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(AsyncCreateDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> PrepareAsyncCreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(PrepareAsyncCreateDatabaseRaw(context, request, cq));
    }
    // 添加已有的业务数据库。对该数据库，系统不执行创建表的过程，而使用库中已有的表。用户需保证库表结构确实符合系统规范。
    virtual ::grpc::Status AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::smart3dmap::v1::Database* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> AsyncAddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(AsyncAddExistingDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> PrepareAsyncAddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(PrepareAsyncAddExistingDatabaseRaw(context, request, cq));
    }
    // 获取业务数据库列表
    virtual ::grpc::Status ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::smart3dmap::v1::ListDatabasesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>> AsyncListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>>(AsyncListDatabasesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>> PrepareAsyncListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>>(PrepareAsyncListDatabasesRaw(context, request, cq));
    }
    // 获取指定业务数据库的信息
    virtual ::grpc::Status GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::smart3dmap::v1::Database* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> AsyncGetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(AsyncGetDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>> PrepareAsyncGetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>>(PrepareAsyncGetDatabaseRaw(context, request, cq));
    }
    // 删除业务数据库。仅删除关于该库的记录，不删除数据库的物理数据。
    virtual ::grpc::Status DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::smart3dmap::v1::DeleteDatabaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>> AsyncDeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>>(AsyncDeleteDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>> PrepareAsyncDeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>>(PrepareAsyncDeleteDatabaseRaw(context, request, cq));
    }
    // 查询工程列表
    virtual ::grpc::Status ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::smart3dmap::v1::ListProjectsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>> AsyncListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>>(AsyncListProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>> PrepareAsyncListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>>(PrepareAsyncListProjectsRaw(context, request, cq));
    }
    // 创建工程
    virtual ::grpc::Status CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::smart3dmap::v1::Project* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>> AsyncCreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>>(AsyncCreateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>> PrepareAsyncCreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>>(PrepareAsyncCreateProjectRaw(context, request, cq));
    }
    // 根据ID查询指定的工程
    virtual ::grpc::Status GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::smart3dmap::v1::Project* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>> AsyncGetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>>(AsyncGetProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>> PrepareAsyncGetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>>(PrepareAsyncGetProjectRaw(context, request, cq));
    }
    // 修改指定的工程
    virtual ::grpc::Status UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::smart3dmap::v1::UpdateProjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>> AsyncUpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>>(AsyncUpdateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>> PrepareAsyncUpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>>(PrepareAsyncUpdateProjectRaw(context, request, cq));
    }
    // 发布工程或撤销已发布的工程
    virtual ::grpc::Status PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::smart3dmap::v1::PublishProjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>> AsyncPublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>>(AsyncPublishProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>> PrepareAsyncPublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>>(PrepareAsyncPublishProjectRaw(context, request, cq));
    }
    // 根据ID删除指定的工程
    virtual ::grpc::Status DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::smart3dmap::v1::DeleteProjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>> AsyncDeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>>(AsyncDeleteProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>> PrepareAsyncDeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>>(PrepareAsyncDeleteProjectRaw(context, request, cq));
    }
    // 标准地层组
    // 创建一个标准地层组
    virtual ::grpc::Status CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::smart3dmap::v1::StdStrat* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>> AsyncCreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>>(AsyncCreateStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>> PrepareAsyncCreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>>(PrepareAsyncCreateStdStratRaw(context, request, cq));
    }
    // 查询标准地层组及其概要信息（不含具体的分层）
    virtual ::grpc::Status ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::smart3dmap::v1::ListStdStratsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>> AsyncListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>>(AsyncListStdStratsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>> PrepareAsyncListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>>(PrepareAsyncListStdStratsRaw(context, request, cq));
    }
    // 获取指定地层组的详细信息（含具体分层信息）
    virtual ::grpc::Status GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::smart3dmap::v1::StdStrat* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>> AsyncGetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>>(AsyncGetStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>> PrepareAsyncGetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>>(PrepareAsyncGetStdStratRaw(context, request, cq));
    }
    // 修改指定地层组的概要信息
    virtual ::grpc::Status UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::smart3dmap::v1::UpdateStdStratResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>> AsyncUpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>>(AsyncUpdateStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>> PrepareAsyncUpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>>(PrepareAsyncUpdateStdStratRaw(context, request, cq));
    }
    // 更新标准地层组中的具体分层信息：一次性全部更新。
    virtual ::grpc::Status ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::smart3dmap::v1::ResetStdStratItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>> AsyncResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>>(AsyncResetStdStratItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>> PrepareAsyncResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>>(PrepareAsyncResetStdStratItemsRaw(context, request, cq));
    }
    // 删除指定的标准地层组
    virtual ::grpc::Status DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::smart3dmap::v1::DeleteStdStratResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>> AsyncDeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>>(AsyncDeleteStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>> PrepareAsyncDeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>>(PrepareAsyncDeleteStdStratRaw(context, request, cq));
    }
    // 逐条导入标准地层的分层记录。每导入一条分层记录均返回对应的操作状态。
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> ImportStdStratItemsByStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(ImportStdStratItemsByStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> AsyncImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(AsyncImportStdStratItemsByStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> PrepareAsyncImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(PrepareAsyncImportStdStratItemsByStreamRaw(context, cq));
    }
    // 批量导入标准地层的分层记录。要么都成功，要么都失败。
    virtual ::grpc::Status ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::smart3dmap::v1::ImportStdStratItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>> AsyncImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>>(AsyncImportStdStratItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>> PrepareAsyncImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>>(PrepareAsyncImportStdStratItemsRaw(context, request, cq));
    }
    // 数据字典：表分类
    virtual ::grpc::Status ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>> AsyncListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>>(AsyncListDicTableCategoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>> PrepareAsyncListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>>(PrepareAsyncListDicTableCategoriesRaw(context, request, cq));
    }
    // 数据字典：表映射信息
    virtual ::grpc::Status ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::smart3dmap::v1::ListDicTablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>> AsyncListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>>(AsyncListDicTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>> PrepareAsyncListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>>(PrepareAsyncListDicTablesRaw(context, request, cq));
    }
    // 数据字典：表及其字段的映射信息
    virtual ::grpc::Status ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::smart3dmap::v1::ListDicTableFieldsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>> AsyncListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>>(AsyncListDicTableFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>> PrepareAsyncListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>>(PrepareAsyncListDicTableFieldsRaw(context, request, cq));
    }
    // 数据字典：配置表和字段映射
    virtual ::grpc::Status ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>> AsyncConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>>(AsyncConfigTableFieldMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>> PrepareAsyncConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>>(PrepareAsyncConfigTableFieldMapRaw(context, request, cq));
    }
    // 获取数据库中的表的列表
    virtual ::grpc::Status ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::smart3dmap::v1::ListTablesInDBResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>> AsyncListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>>(AsyncListTablesInDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>> PrepareAsyncListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>>(PrepareAsyncListTablesInDBRaw(context, request, cq));
    }
    // 获取表的字段的列表
    virtual ::grpc::Status ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::smart3dmap::v1::ListFieldsOfTableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>> AsyncListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>>(AsyncListFieldsOfTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>> PrepareAsyncListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>>(PrepareAsyncListFieldsOfTableRaw(context, request, cq));
    }
    // 获取数据资源类型列表
    virtual ::grpc::Status ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::smart3dmap::v1::ListDataResourceTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>> AsyncListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>>(AsyncListDataResourceTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>> PrepareAsyncListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>>(PrepareAsyncListDataResourceTypesRaw(context, request, cq));
    }
    // 获取二维地图列表
    virtual ::grpc::Status ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::smart3dmap::v1::ListMapsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>> AsyncListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>>(AsyncListMapsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>> PrepareAsyncListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>>(PrepareAsyncListMapsRaw(context, request, cq));
    }
    // 获取二维地图信息
    virtual ::grpc::Status GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::smart3dmap::v1::Map* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>> AsyncGetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>>(AsyncGetMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>>(PrepareAsyncGetMapRaw(context, request, cq));
    }
    // 获取二维地图中的图层
    std::unique_ptr< ::grpc::ClientReaderInterface< ::smart3dmap::v1::Layer>> ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::smart3dmap::v1::Layer>>(ListLayersOfMapRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>> AsyncListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>>(AsyncListLayersOfMapRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>> PrepareAsyncListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>>(PrepareAsyncListLayersOfMapRaw(context, request, cq));
    }
    virtual ::grpc::Status ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>> AsyncListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>>(AsyncListLayersOfMapByPageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>> PrepareAsyncListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>>(PrepareAsyncListLayersOfMapByPageRaw(context, request, cq));
    }
    // 获取指定栅格图层的数据
    virtual ::grpc::Status GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::smart3dmap::v1::RasterLayerData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>> AsyncGetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>>(AsyncGetRasterLayerDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>> PrepareAsyncGetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>>(PrepareAsyncGetRasterLayerDataRaw(context, request, cq));
    }
    // 删除指定的地图。需要提前从MapService中撤销发布该地图。
    virtual ::grpc::Status DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::smart3dmap::v1::DeleteMapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>> AsyncDeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>>(AsyncDeleteMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>> PrepareAsyncDeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>>(PrepareAsyncDeleteMapRaw(context, request, cq));
    }
    // 查询地质调查工程/项目列表
    virtual ::grpc::Status ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>> AsyncListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>>(AsyncListGeoSurveyProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>> PrepareAsyncListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>>(PrepareAsyncListGeoSurveyProjectsRaw(context, request, cq));
    }
    // 获取指定地质调查项目的信息
    virtual ::grpc::Status GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::smart3dmap::v1::GeoSurveyProject* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>> AsyncGetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>>(AsyncGetGeoSurveyProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>> PrepareAsyncGetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>>(PrepareAsyncGetGeoSurveyProjectRaw(context, request, cq));
    }
    // 分页查询指定数据库中的钻孔
    virtual ::grpc::Status ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::smart3dmap::v1::ListDrillsByPageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>> AsyncListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>>(AsyncListDrillsByPageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>> PrepareAsyncListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>>(PrepareAsyncListDrillsByPageRaw(context, request, cq));
    }
    // 流式查询指定数据库中的钻孔
    std::unique_ptr< ::grpc::ClientReaderInterface< ::smart3dmap::v1::Drill>> ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::smart3dmap::v1::Drill>>(ListDrillsByStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>> AsyncListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>>(AsyncListDrillsByStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>> PrepareAsyncListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>>(PrepareAsyncListDrillsByStreamRaw(context, request, cq));
    }
    // 查询指定钻孔的基本信息
    virtual ::grpc::Status GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::smart3dmap::v1::Drill* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>> AsyncGetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>>(AsyncGetDrillRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>> PrepareAsyncGetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>>(PrepareAsyncGetDrillRaw(context, request, cq));
    }
    // 获取指定钻孔的标准分层信息
    virtual ::grpc::Status GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::smart3dmap::v1::DrillStdLayers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>> AsyncGetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>>(AsyncGetDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>> PrepareAsyncGetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>>(PrepareAsyncGetDrillStdLayersRaw(context, request, cq));
    }
    // 获取指定钻孔的原始分层信息
    virtual ::grpc::Status GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::smart3dmap::v1::DrillOriginalLayers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>> AsyncGetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>>(AsyncGetDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>> PrepareAsyncGetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>>(PrepareAsyncGetDrillOriginalLayersRaw(context, request, cq));
    }
    // 分页查询钻孔柱状图列表
    virtual ::grpc::Status ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::smart3dmap::v1::ListDrillLogsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>> AsyncListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>>(AsyncListDillLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>> PrepareAsyncListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>>(PrepareAsyncListDillLogsRaw(context, request, cq));
    }
    // 分页查询剖面图列表
    virtual ::grpc::Status ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::smart3dmap::v1::ListSectionMapsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>> AsyncListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>>(AsyncListSectionMapsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>> PrepareAsyncListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>>(PrepareAsyncListSectionMapsRaw(context, request, cq));
    }
    // 分页查询三维结构模型列表
    virtual ::grpc::Status ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::smart3dmap::v1::ListStructureModelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>> AsyncListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>>(AsyncListStructureModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>> PrepareAsyncListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>>(PrepareAsyncListStructureModelsRaw(context, request, cq));
    }
    // 分页查询三维属性模型列表
    virtual ::grpc::Status ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::smart3dmap::v1::ListFieldModelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>> AsyncListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>>(AsyncListFieldModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>> PrepareAsyncListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>>(PrepareAsyncListFieldModelsRaw(context, request, cq));
    }
    // 删除指定的模型。
    virtual ::grpc::Status DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::smart3dmap::v1::DeleteModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>> AsyncDeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>>(AsyncDeleteModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>> PrepareAsyncDeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>>(PrepareAsyncDeleteModelRaw(context, request, cq));
    }
    // 导出三维地质模型的元数据（仅支持XML文件格式）。导出的数据可作为模板用于编辑更新模型的元数据。
    virtual ::grpc::Status ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::smart3dmap::v1::ExportModelMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>> AsyncExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>>(AsyncExportModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>> PrepareAsyncExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>>(PrepareAsyncExportModelMetadataRaw(context, request, cq));
    }
    // 导入三维地质模型的元数据（仅支持XML文件格式）。按导入的数据完整更新三维地质模型的元数据。
    virtual ::grpc::Status ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::smart3dmap::v1::ImportModelMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>> AsyncImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>>(AsyncImportModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>> PrepareAsyncImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>>(PrepareAsyncImportModelMetadataRaw(context, request, cq));
    }
    // 钻孔数据入库
    // 新增地质调查工程/项目记录
    virtual ::grpc::Status CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::smart3dmap::v1::GeoSurveyProject* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>> AsyncCreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>>(AsyncCreateGeoSurveyProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>> PrepareAsyncCreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>>(PrepareAsyncCreateGeoSurveyProjectRaw(context, request, cq));
    }
    // 新增钻孔记录。每导入一个钻孔记录都返回其对应的操作结果。
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> ImportDrillsByStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(ImportDrillsByStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> AsyncImportDrillsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(AsyncImportDrillsByStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> PrepareAsyncImportDrillsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(PrepareAsyncImportDrillsByStreamRaw(context, cq));
    }
    // 批量导入钻孔记录。要么都成功，要么都失败。
    virtual ::grpc::Status ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::smart3dmap::v1::ImportDrillsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>> AsyncImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>>(AsyncImportDrillsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>> PrepareAsyncImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>>(PrepareAsyncImportDrillsRaw(context, request, cq));
    }
    // 导入钻孔的原始分层信息
    virtual ::grpc::Status ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillOriginalLayersRaw(context, request, cq));
    }
    // 删除钻孔的原始分层信息
    virtual ::grpc::Status DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillOriginalLayersRaw(context, request, cq));
    }
    // 导入钻孔的标准分层信息
    virtual ::grpc::Status ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillStdLayersRaw(context, request, cq));
    }
    // 删除钻孔的标准分层信息
    virtual ::grpc::Status DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillStdLayersRaw(context, request, cq));
    }
    // 导入水腐蚀性分析记录。
    virtual ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillWaterCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillWaterCorrosivityRaw(context, request, cq));
    }
    // 删除钻孔的水腐蚀性分析记录。
    virtual ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillWaterCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillWaterCorrosivityRaw(context, request, cq));
    }
    // 导入土腐蚀性分析记录。
    virtual ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillSoilCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillSoilCorrosivityRaw(context, request, cq));
    }
    // 删除钻孔的土腐蚀性分析记录。
    virtual ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillSoilCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillSoilCorrosivityRaw(context, request, cq));
    }
    // 导入土工实验数据。
    virtual ::grpc::Status ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportGeotechnicalRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportGeotechnicalRecordsRaw(context, request, cq));
    }
    // 删除钻孔的土工试验数据。
    virtual ::grpc::Status DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteGeotechnicalRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteGeotechnicalRecordsRaw(context, request, cq));
    }
    // 导入标贯实验数据。
    virtual ::grpc::Status ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportStdPenetrationRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportStdPenetrationRecordRaw(context, request, cq));
    }
    // 删除钻孔标贯实验数据。
    virtual ::grpc::Status DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteStdPenetrationRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteStdPenetrationRecordsRaw(context, request, cq));
    }
    // 导入钻孔抗压强度试验数据
    virtual ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportCompressiveResistanceRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportCompressiveResistanceRecordsRaw(context, request, cq));
    }
    // 删除钻孔抗压强度试验数据。
    virtual ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteCompressiveResistanceRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteCompressiveResistanceRecordsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 查询支持的数据库服务器类型信息
      virtual void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 添加数据库服务器
      virtual void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取可用的数据库服务器列表
      virtual void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定的数据库服务器的详细信息。
      virtual void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 修改指定的数据库服务器的信息。
      virtual void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除指定的数据库服务器。仅该数据库服务器没有关联任何数据库时才可被删除。
      virtual void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 查询业务数据库的分类信息
      virtual void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 创建业务数据库
      virtual void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 添加已有的业务数据库。对该数据库，系统不执行创建表的过程，而使用库中已有的表。用户需保证库表结构确实符合系统规范。
      virtual void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取业务数据库列表
      virtual void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定业务数据库的信息
      virtual void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除业务数据库。仅删除关于该库的记录，不删除数据库的物理数据。
      virtual void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 查询工程列表
      virtual void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 创建工程
      virtual void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 根据ID查询指定的工程
      virtual void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 修改指定的工程
      virtual void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 发布工程或撤销已发布的工程
      virtual void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 根据ID删除指定的工程
      virtual void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 标准地层组
      // 创建一个标准地层组
      virtual void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 查询标准地层组及其概要信息（不含具体的分层）
      virtual void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定地层组的详细信息（含具体分层信息）
      virtual void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 修改指定地层组的概要信息
      virtual void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 更新标准地层组中的具体分层信息：一次性全部更新。
      virtual void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除指定的标准地层组
      virtual void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 逐条导入标准地层的分层记录。每导入一条分层记录均返回对应的操作状态。
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::smart3dmap::v1::ImportedStdStratItem,::smart3dmap::v1::ImportStdStratItemStatus>* reactor) = 0;
      #else
      virtual void ImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::smart3dmap::v1::ImportedStdStratItem,::smart3dmap::v1::ImportStdStratItemStatus>* reactor) = 0;
      #endif
      // 批量导入标准地层的分层记录。要么都成功，要么都失败。
      virtual void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 数据字典：表分类
      virtual void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 数据字典：表映射信息
      virtual void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 数据字典：表及其字段的映射信息
      virtual void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 数据字典：配置表和字段映射
      virtual void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取数据库中的表的列表
      virtual void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取表的字段的列表
      virtual void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取数据资源类型列表
      virtual void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取二维地图列表
      virtual void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取二维地图信息
      virtual void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取二维地图中的图层
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::ClientReadReactor< ::smart3dmap::v1::Layer>* reactor) = 0;
      #else
      virtual void ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::experimental::ClientReadReactor< ::smart3dmap::v1::Layer>* reactor) = 0;
      #endif
      virtual void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定栅格图层的数据
      virtual void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除指定的地图。需要提前从MapService中撤销发布该地图。
      virtual void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 查询地质调查工程/项目列表
      virtual void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定地质调查项目的信息
      virtual void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 分页查询指定数据库中的钻孔
      virtual void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 流式查询指定数据库中的钻孔
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::ClientReadReactor< ::smart3dmap::v1::Drill>* reactor) = 0;
      #else
      virtual void ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::experimental::ClientReadReactor< ::smart3dmap::v1::Drill>* reactor) = 0;
      #endif
      // 查询指定钻孔的基本信息
      virtual void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定钻孔的标准分层信息
      virtual void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 获取指定钻孔的原始分层信息
      virtual void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 分页查询钻孔柱状图列表
      virtual void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 分页查询剖面图列表
      virtual void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 分页查询三维结构模型列表
      virtual void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 分页查询三维属性模型列表
      virtual void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除指定的模型。
      virtual void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导出三维地质模型的元数据（仅支持XML文件格式）。导出的数据可作为模板用于编辑更新模型的元数据。
      virtual void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入三维地质模型的元数据（仅支持XML文件格式）。按导入的数据完整更新三维地质模型的元数据。
      virtual void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 钻孔数据入库
      // 新增地质调查工程/项目记录
      virtual void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 新增钻孔记录。每导入一个钻孔记录都返回其对应的操作结果。
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrillsByStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::smart3dmap::v1::Drill,::smart3dmap::v1::ImportDrillStatus>* reactor) = 0;
      #else
      virtual void ImportDrillsByStream(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::smart3dmap::v1::Drill,::smart3dmap::v1::ImportDrillStatus>* reactor) = 0;
      #endif
      // 批量导入钻孔记录。要么都成功，要么都失败。
      virtual void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入钻孔的原始分层信息
      virtual void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔的原始分层信息
      virtual void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入钻孔的标准分层信息
      virtual void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔的标准分层信息
      virtual void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入水腐蚀性分析记录。
      virtual void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔的水腐蚀性分析记录。
      virtual void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入土腐蚀性分析记录。
      virtual void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔的土腐蚀性分析记录。
      virtual void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入土工实验数据。
      virtual void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔的土工试验数据。
      virtual void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入标贯实验数据。
      virtual void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔标贯实验数据。
      virtual void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 导入钻孔抗压强度试验数据
      virtual void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 删除钻孔抗压强度试验数据。
      virtual void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>* AsyncListDBServerTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDBServerTypesResponse>* PrepareAsyncListDBServerTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>* AsyncCreateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>* PrepareAsyncCreateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>* AsyncListDatabaseServersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseServersResponse>* PrepareAsyncListDatabaseServersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>* AsyncGetDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DBServer>* PrepareAsyncGetDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>* AsyncUpdateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateDatabaseServerResponse>* PrepareAsyncUpdateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>* AsyncDeleteDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseServerResponse>* PrepareAsyncDeleteDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>* AsyncListDatabaseAppTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabaseAppTypesResponse>* PrepareAsyncListDatabaseAppTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* AsyncCreateDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* PrepareAsyncCreateDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* AsyncAddExistingDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* PrepareAsyncAddExistingDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>* AsyncListDatabasesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDatabasesResponse>* PrepareAsyncListDatabasesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* AsyncGetDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Database>* PrepareAsyncGetDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>* AsyncDeleteDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDatabaseResponse>* PrepareAsyncDeleteDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>* AsyncListProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListProjectsResponse>* PrepareAsyncListProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>* AsyncCreateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>* PrepareAsyncCreateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>* AsyncGetProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Project>* PrepareAsyncGetProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>* AsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateProjectResponse>* PrepareAsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>* AsyncPublishProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::PublishProjectResponse>* PrepareAsyncPublishProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>* AsyncDeleteProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteProjectResponse>* PrepareAsyncDeleteProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>* AsyncCreateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>* PrepareAsyncCreateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>* AsyncListStdStratsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStdStratsResponse>* PrepareAsyncListStdStratsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>* AsyncGetStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::StdStrat>* PrepareAsyncGetStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>* AsyncUpdateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::UpdateStdStratResponse>* PrepareAsyncUpdateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>* AsyncResetStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ResetStdStratItemsResponse>* PrepareAsyncResetStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>* AsyncDeleteStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteStdStratResponse>* PrepareAsyncDeleteStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* ImportStdStratItemsByStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* AsyncImportStdStratItemsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* PrepareAsyncImportStdStratItemsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>* AsyncImportStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportStdStratItemsResponse>* PrepareAsyncImportStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>* AsyncListDicTableCategoriesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableCategoriesResponse>* PrepareAsyncListDicTableCategoriesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>* AsyncListDicTablesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTablesResponse>* PrepareAsyncListDicTablesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>* AsyncListDicTableFieldsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDicTableFieldsResponse>* PrepareAsyncListDicTableFieldsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>* AsyncConfigTableFieldMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ConfigTableFieldMapResponse>* PrepareAsyncConfigTableFieldMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>* AsyncListTablesInDBRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListTablesInDBResponse>* PrepareAsyncListTablesInDBRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>* AsyncListFieldsOfTableRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldsOfTableResponse>* PrepareAsyncListFieldsOfTableRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>* AsyncListDataResourceTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDataResourceTypesResponse>* PrepareAsyncListDataResourceTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>* AsyncListMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListMapsResponse>* PrepareAsyncListMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Map>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::smart3dmap::v1::Layer>* ListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>* AsyncListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Layer>* PrepareAsyncListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>* AsyncListLayersOfMapByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListLayersOfMapByPageResponse>* PrepareAsyncListLayersOfMapByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>* AsyncGetRasterLayerDataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::RasterLayerData>* PrepareAsyncGetRasterLayerDataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>* AsyncDeleteMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteMapResponse>* PrepareAsyncDeleteMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* AsyncListGeoSurveyProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* PrepareAsyncListGeoSurveyProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>* AsyncGetGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>* PrepareAsyncGetGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>* AsyncListDrillsByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillsByPageResponse>* PrepareAsyncListDrillsByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::smart3dmap::v1::Drill>* ListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>* AsyncListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::smart3dmap::v1::Drill>* PrepareAsyncListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>* AsyncGetDrillRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::Drill>* PrepareAsyncGetDrillRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>* AsyncGetDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillStdLayers>* PrepareAsyncGetDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>* AsyncGetDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DrillOriginalLayers>* PrepareAsyncGetDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>* AsyncListDillLogsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListDrillLogsResponse>* PrepareAsyncListDillLogsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>* AsyncListSectionMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListSectionMapsResponse>* PrepareAsyncListSectionMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>* AsyncListStructureModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListStructureModelsResponse>* PrepareAsyncListStructureModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>* AsyncListFieldModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ListFieldModelsResponse>* PrepareAsyncListFieldModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>* AsyncDeleteModelRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteModelResponse>* PrepareAsyncDeleteModelRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>* AsyncExportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ExportModelMetadataResponse>* PrepareAsyncExportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>* AsyncImportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportModelMetadataResponse>* PrepareAsyncImportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>* AsyncCreateGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::GeoSurveyProject>* PrepareAsyncCreateGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* ImportDrillsByStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* AsyncImportDrillsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* PrepareAsyncImportDrillsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>* AsyncImportDrillsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillsResponse>* PrepareAsyncImportDrillsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportStdPenetrationRecordRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportStdPenetrationRecordRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteStdPenetrationRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteStdPenetrationRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::smart3dmap::v1::ListDBServerTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>> AsyncListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>>(AsyncListDBServerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>> PrepareAsyncListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>>(PrepareAsyncListDBServerTypesRaw(context, request, cq));
    }
    ::grpc::Status CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::smart3dmap::v1::DBServer* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>> AsyncCreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>>(AsyncCreateDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>> PrepareAsyncCreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>>(PrepareAsyncCreateDatabaseServerRaw(context, request, cq));
    }
    ::grpc::Status ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::smart3dmap::v1::ListDatabaseServersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>> AsyncListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>>(AsyncListDatabaseServersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>> PrepareAsyncListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>>(PrepareAsyncListDatabaseServersRaw(context, request, cq));
    }
    ::grpc::Status GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::smart3dmap::v1::DBServer* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>> AsyncGetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>>(AsyncGetDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>> PrepareAsyncGetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>>(PrepareAsyncGetDatabaseServerRaw(context, request, cq));
    }
    ::grpc::Status UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>> AsyncUpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>>(AsyncUpdateDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>> PrepareAsyncUpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>>(PrepareAsyncUpdateDatabaseServerRaw(context, request, cq));
    }
    ::grpc::Status DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>> AsyncDeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>>(AsyncDeleteDatabaseServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>> PrepareAsyncDeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>>(PrepareAsyncDeleteDatabaseServerRaw(context, request, cq));
    }
    ::grpc::Status ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>> AsyncListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>>(AsyncListDatabaseAppTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>> PrepareAsyncListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>>(PrepareAsyncListDatabaseAppTypesRaw(context, request, cq));
    }
    ::grpc::Status CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::smart3dmap::v1::Database* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> AsyncCreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(AsyncCreateDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> PrepareAsyncCreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(PrepareAsyncCreateDatabaseRaw(context, request, cq));
    }
    ::grpc::Status AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::smart3dmap::v1::Database* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> AsyncAddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(AsyncAddExistingDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> PrepareAsyncAddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(PrepareAsyncAddExistingDatabaseRaw(context, request, cq));
    }
    ::grpc::Status ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::smart3dmap::v1::ListDatabasesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>> AsyncListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>>(AsyncListDatabasesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>> PrepareAsyncListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>>(PrepareAsyncListDatabasesRaw(context, request, cq));
    }
    ::grpc::Status GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::smart3dmap::v1::Database* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> AsyncGetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(AsyncGetDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>> PrepareAsyncGetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>>(PrepareAsyncGetDatabaseRaw(context, request, cq));
    }
    ::grpc::Status DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::smart3dmap::v1::DeleteDatabaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>> AsyncDeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>>(AsyncDeleteDatabaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>> PrepareAsyncDeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>>(PrepareAsyncDeleteDatabaseRaw(context, request, cq));
    }
    ::grpc::Status ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::smart3dmap::v1::ListProjectsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>> AsyncListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>>(AsyncListProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>> PrepareAsyncListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>>(PrepareAsyncListProjectsRaw(context, request, cq));
    }
    ::grpc::Status CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::smart3dmap::v1::Project* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>> AsyncCreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>>(AsyncCreateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>> PrepareAsyncCreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>>(PrepareAsyncCreateProjectRaw(context, request, cq));
    }
    ::grpc::Status GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::smart3dmap::v1::Project* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>> AsyncGetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>>(AsyncGetProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>> PrepareAsyncGetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>>(PrepareAsyncGetProjectRaw(context, request, cq));
    }
    ::grpc::Status UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::smart3dmap::v1::UpdateProjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>> AsyncUpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>>(AsyncUpdateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>> PrepareAsyncUpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>>(PrepareAsyncUpdateProjectRaw(context, request, cq));
    }
    ::grpc::Status PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::smart3dmap::v1::PublishProjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>> AsyncPublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>>(AsyncPublishProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>> PrepareAsyncPublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>>(PrepareAsyncPublishProjectRaw(context, request, cq));
    }
    ::grpc::Status DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::smart3dmap::v1::DeleteProjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>> AsyncDeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>>(AsyncDeleteProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>> PrepareAsyncDeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>>(PrepareAsyncDeleteProjectRaw(context, request, cq));
    }
    ::grpc::Status CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::smart3dmap::v1::StdStrat* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>> AsyncCreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>>(AsyncCreateStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>> PrepareAsyncCreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>>(PrepareAsyncCreateStdStratRaw(context, request, cq));
    }
    ::grpc::Status ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::smart3dmap::v1::ListStdStratsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>> AsyncListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>>(AsyncListStdStratsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>> PrepareAsyncListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>>(PrepareAsyncListStdStratsRaw(context, request, cq));
    }
    ::grpc::Status GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::smart3dmap::v1::StdStrat* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>> AsyncGetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>>(AsyncGetStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>> PrepareAsyncGetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>>(PrepareAsyncGetStdStratRaw(context, request, cq));
    }
    ::grpc::Status UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::smart3dmap::v1::UpdateStdStratResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>> AsyncUpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>>(AsyncUpdateStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>> PrepareAsyncUpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>>(PrepareAsyncUpdateStdStratRaw(context, request, cq));
    }
    ::grpc::Status ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::smart3dmap::v1::ResetStdStratItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>> AsyncResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>>(AsyncResetStdStratItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>> PrepareAsyncResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>>(PrepareAsyncResetStdStratItemsRaw(context, request, cq));
    }
    ::grpc::Status DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::smart3dmap::v1::DeleteStdStratResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>> AsyncDeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>>(AsyncDeleteStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>> PrepareAsyncDeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>>(PrepareAsyncDeleteStdStratRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> ImportStdStratItemsByStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(ImportStdStratItemsByStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> AsyncImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(AsyncImportStdStratItemsByStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>> PrepareAsyncImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>>(PrepareAsyncImportStdStratItemsByStreamRaw(context, cq));
    }
    ::grpc::Status ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::smart3dmap::v1::ImportStdStratItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>> AsyncImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>>(AsyncImportStdStratItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>> PrepareAsyncImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>>(PrepareAsyncImportStdStratItemsRaw(context, request, cq));
    }
    ::grpc::Status ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>> AsyncListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>>(AsyncListDicTableCategoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>> PrepareAsyncListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>>(PrepareAsyncListDicTableCategoriesRaw(context, request, cq));
    }
    ::grpc::Status ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::smart3dmap::v1::ListDicTablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>> AsyncListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>>(AsyncListDicTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>> PrepareAsyncListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>>(PrepareAsyncListDicTablesRaw(context, request, cq));
    }
    ::grpc::Status ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::smart3dmap::v1::ListDicTableFieldsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>> AsyncListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>>(AsyncListDicTableFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>> PrepareAsyncListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>>(PrepareAsyncListDicTableFieldsRaw(context, request, cq));
    }
    ::grpc::Status ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>> AsyncConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>>(AsyncConfigTableFieldMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>> PrepareAsyncConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>>(PrepareAsyncConfigTableFieldMapRaw(context, request, cq));
    }
    ::grpc::Status ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::smart3dmap::v1::ListTablesInDBResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>> AsyncListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>>(AsyncListTablesInDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>> PrepareAsyncListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>>(PrepareAsyncListTablesInDBRaw(context, request, cq));
    }
    ::grpc::Status ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::smart3dmap::v1::ListFieldsOfTableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>> AsyncListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>>(AsyncListFieldsOfTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>> PrepareAsyncListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>>(PrepareAsyncListFieldsOfTableRaw(context, request, cq));
    }
    ::grpc::Status ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::smart3dmap::v1::ListDataResourceTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>> AsyncListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>>(AsyncListDataResourceTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>> PrepareAsyncListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>>(PrepareAsyncListDataResourceTypesRaw(context, request, cq));
    }
    ::grpc::Status ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::smart3dmap::v1::ListMapsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>> AsyncListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>>(AsyncListMapsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>> PrepareAsyncListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>>(PrepareAsyncListMapsRaw(context, request, cq));
    }
    ::grpc::Status GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::smart3dmap::v1::Map* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>> AsyncGetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>>(AsyncGetMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>>(PrepareAsyncGetMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::smart3dmap::v1::Layer>> ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::smart3dmap::v1::Layer>>(ListLayersOfMapRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>> AsyncListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>>(AsyncListLayersOfMapRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>> PrepareAsyncListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>>(PrepareAsyncListLayersOfMapRaw(context, request, cq));
    }
    ::grpc::Status ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>> AsyncListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>>(AsyncListLayersOfMapByPageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>> PrepareAsyncListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>>(PrepareAsyncListLayersOfMapByPageRaw(context, request, cq));
    }
    ::grpc::Status GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::smart3dmap::v1::RasterLayerData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>> AsyncGetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>>(AsyncGetRasterLayerDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>> PrepareAsyncGetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>>(PrepareAsyncGetRasterLayerDataRaw(context, request, cq));
    }
    ::grpc::Status DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::smart3dmap::v1::DeleteMapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>> AsyncDeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>>(AsyncDeleteMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>> PrepareAsyncDeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>>(PrepareAsyncDeleteMapRaw(context, request, cq));
    }
    ::grpc::Status ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>> AsyncListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>>(AsyncListGeoSurveyProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>> PrepareAsyncListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>>(PrepareAsyncListGeoSurveyProjectsRaw(context, request, cq));
    }
    ::grpc::Status GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::smart3dmap::v1::GeoSurveyProject* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>> AsyncGetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>>(AsyncGetGeoSurveyProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>> PrepareAsyncGetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>>(PrepareAsyncGetGeoSurveyProjectRaw(context, request, cq));
    }
    ::grpc::Status ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::smart3dmap::v1::ListDrillsByPageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>> AsyncListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>>(AsyncListDrillsByPageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>> PrepareAsyncListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>>(PrepareAsyncListDrillsByPageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::smart3dmap::v1::Drill>> ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::smart3dmap::v1::Drill>>(ListDrillsByStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>> AsyncListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>>(AsyncListDrillsByStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>> PrepareAsyncListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>>(PrepareAsyncListDrillsByStreamRaw(context, request, cq));
    }
    ::grpc::Status GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::smart3dmap::v1::Drill* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>> AsyncGetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>>(AsyncGetDrillRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>> PrepareAsyncGetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>>(PrepareAsyncGetDrillRaw(context, request, cq));
    }
    ::grpc::Status GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::smart3dmap::v1::DrillStdLayers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>> AsyncGetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>>(AsyncGetDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>> PrepareAsyncGetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>>(PrepareAsyncGetDrillStdLayersRaw(context, request, cq));
    }
    ::grpc::Status GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::smart3dmap::v1::DrillOriginalLayers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>> AsyncGetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>>(AsyncGetDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>> PrepareAsyncGetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>>(PrepareAsyncGetDrillOriginalLayersRaw(context, request, cq));
    }
    ::grpc::Status ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::smart3dmap::v1::ListDrillLogsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>> AsyncListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>>(AsyncListDillLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>> PrepareAsyncListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>>(PrepareAsyncListDillLogsRaw(context, request, cq));
    }
    ::grpc::Status ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::smart3dmap::v1::ListSectionMapsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>> AsyncListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>>(AsyncListSectionMapsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>> PrepareAsyncListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>>(PrepareAsyncListSectionMapsRaw(context, request, cq));
    }
    ::grpc::Status ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::smart3dmap::v1::ListStructureModelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>> AsyncListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>>(AsyncListStructureModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>> PrepareAsyncListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>>(PrepareAsyncListStructureModelsRaw(context, request, cq));
    }
    ::grpc::Status ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::smart3dmap::v1::ListFieldModelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>> AsyncListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>>(AsyncListFieldModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>> PrepareAsyncListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>>(PrepareAsyncListFieldModelsRaw(context, request, cq));
    }
    ::grpc::Status DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::smart3dmap::v1::DeleteModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>> AsyncDeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>>(AsyncDeleteModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>> PrepareAsyncDeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>>(PrepareAsyncDeleteModelRaw(context, request, cq));
    }
    ::grpc::Status ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::smart3dmap::v1::ExportModelMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>> AsyncExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>>(AsyncExportModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>> PrepareAsyncExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>>(PrepareAsyncExportModelMetadataRaw(context, request, cq));
    }
    ::grpc::Status ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::smart3dmap::v1::ImportModelMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>> AsyncImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>>(AsyncImportModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>> PrepareAsyncImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>>(PrepareAsyncImportModelMetadataRaw(context, request, cq));
    }
    ::grpc::Status CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::smart3dmap::v1::GeoSurveyProject* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>> AsyncCreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>>(AsyncCreateGeoSurveyProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>> PrepareAsyncCreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>>(PrepareAsyncCreateGeoSurveyProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> ImportDrillsByStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(ImportDrillsByStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> AsyncImportDrillsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(AsyncImportDrillsByStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>> PrepareAsyncImportDrillsByStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>>(PrepareAsyncImportDrillsByStreamRaw(context, cq));
    }
    ::grpc::Status ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::smart3dmap::v1::ImportDrillsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>> AsyncImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>>(AsyncImportDrillsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>> PrepareAsyncImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>>(PrepareAsyncImportDrillsRaw(context, request, cq));
    }
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillOriginalLayersRaw(context, request, cq));
    }
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillOriginalLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillOriginalLayersRaw(context, request, cq));
    }
    ::grpc::Status ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillStdLayersRaw(context, request, cq));
    }
    ::grpc::Status DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillStdLayersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillStdLayersRaw(context, request, cq));
    }
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillWaterCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillWaterCorrosivityRaw(context, request, cq));
    }
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillWaterCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillWaterCorrosivityRaw(context, request, cq));
    }
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportDrillSoilCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportDrillSoilCorrosivityRaw(context, request, cq));
    }
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteDrillSoilCorrosivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteDrillSoilCorrosivityRaw(context, request, cq));
    }
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportGeotechnicalRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportGeotechnicalRecordsRaw(context, request, cq));
    }
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteGeotechnicalRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteGeotechnicalRecordsRaw(context, request, cq));
    }
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportStdPenetrationRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportStdPenetrationRecordRaw(context, request, cq));
    }
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteStdPenetrationRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteStdPenetrationRecordsRaw(context, request, cq));
    }
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::smart3dmap::v1::ImportDrillDataStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> AsyncImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(AsyncImportCompressiveResistanceRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>> PrepareAsyncImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>>(PrepareAsyncImportCompressiveResistanceRecordsRaw(context, request, cq));
    }
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::smart3dmap::v1::DeleteDrillDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> AsyncDeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(AsyncDeleteCompressiveResistanceRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>> PrepareAsyncDeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>>(PrepareAsyncDeleteCompressiveResistanceRecordsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDBServerTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDatabaseServers(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDatabaseServer(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDatabaseAppTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddExistingDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDatabases(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDatabase(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateProject(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PublishProject(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteProject(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListStdStrats(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResetStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteStdStrat(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::smart3dmap::v1::ImportedStdStratItem,::smart3dmap::v1::ImportStdStratItemStatus>* reactor) override;
      #else
      void ImportStdStratItemsByStream(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::smart3dmap::v1::ImportedStdStratItem,::smart3dmap::v1::ImportStdStratItemStatus>* reactor) override;
      #endif
      void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportStdStratItems(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDicTableCategories(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDicTables(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDicTableFields(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ConfigTableFieldMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTablesInDB(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListFieldsOfTable(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDataResourceTypes(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetMap(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::ClientReadReactor< ::smart3dmap::v1::Layer>* reactor) override;
      #else
      void ListLayersOfMap(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::experimental::ClientReadReactor< ::smart3dmap::v1::Layer>* reactor) override;
      #endif
      void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListLayersOfMapByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRasterLayerData(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteMap(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListGeoSurveyProjects(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDrillsByPage(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::ClientReadReactor< ::smart3dmap::v1::Drill>* reactor) override;
      #else
      void ListDrillsByStream(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::experimental::ClientReadReactor< ::smart3dmap::v1::Drill>* reactor) override;
      #endif
      void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetDrill(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListDillLogs(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSectionMaps(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListStructureModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListFieldModels(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModel(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportModelMetadata(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateGeoSurveyProject(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrillsByStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::smart3dmap::v1::Drill,::smart3dmap::v1::ImportDrillStatus>* reactor) override;
      #else
      void ImportDrillsByStream(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::smart3dmap::v1::Drill,::smart3dmap::v1::ImportDrillStatus>* reactor) override;
      #endif
      void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportDrills(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDrillOriginalLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDrillStdLayers(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDrillWaterCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteDrillSoilCorrosivity(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteGeotechnicalRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportStdPenetrationRecord(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteStdPenetrationRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteCompressiveResistanceRecords(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>* AsyncListDBServerTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDBServerTypesResponse>* PrepareAsyncListDBServerTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>* AsyncCreateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>* PrepareAsyncCreateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>* AsyncListDatabaseServersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseServersResponse>* PrepareAsyncListDatabaseServersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>* AsyncGetDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DBServer>* PrepareAsyncGetDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>* AsyncUpdateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateDatabaseServerResponse>* PrepareAsyncUpdateDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>* AsyncDeleteDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseServerResponse>* PrepareAsyncDeleteDatabaseServerRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>* AsyncListDatabaseAppTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabaseAppTypesResponse>* PrepareAsyncListDatabaseAppTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* AsyncCreateDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* PrepareAsyncCreateDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* AsyncAddExistingDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* PrepareAsyncAddExistingDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>* AsyncListDatabasesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDatabasesResponse>* PrepareAsyncListDatabasesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDatabasesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* AsyncGetDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Database>* PrepareAsyncGetDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>* AsyncDeleteDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDatabaseResponse>* PrepareAsyncDeleteDatabaseRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>* AsyncListProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListProjectsResponse>* PrepareAsyncListProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListProjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>* AsyncCreateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>* PrepareAsyncCreateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>* AsyncGetProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Project>* PrepareAsyncGetProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>* AsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateProjectResponse>* PrepareAsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>* AsyncPublishProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::PublishProjectResponse>* PrepareAsyncPublishProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::PublishProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>* AsyncDeleteProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteProjectResponse>* PrepareAsyncDeleteProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>* AsyncCreateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>* PrepareAsyncCreateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::CreateStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>* AsyncListStdStratsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStdStratsResponse>* PrepareAsyncListStdStratsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStdStratsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>* AsyncGetStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::StdStrat>* PrepareAsyncGetStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>* AsyncUpdateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::UpdateStdStratResponse>* PrepareAsyncUpdateStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::UpdateStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>* AsyncResetStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ResetStdStratItemsResponse>* PrepareAsyncResetStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>* AsyncDeleteStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteStdStratResponse>* PrepareAsyncDeleteStdStratRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteStdStratRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* ImportStdStratItemsByStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* AsyncImportStdStratItemsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* PrepareAsyncImportStdStratItemsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>* AsyncImportStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportStdStratItemsResponse>* PrepareAsyncImportStdStratItemsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>* AsyncListDicTableCategoriesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableCategoriesResponse>* PrepareAsyncListDicTableCategoriesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>* AsyncListDicTablesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTablesResponse>* PrepareAsyncListDicTablesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>* AsyncListDicTableFieldsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDicTableFieldsResponse>* PrepareAsyncListDicTableFieldsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>* AsyncConfigTableFieldMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ConfigTableFieldMapResponse>* PrepareAsyncConfigTableFieldMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>* AsyncListTablesInDBRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListTablesInDBResponse>* PrepareAsyncListTablesInDBRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListTablesInDBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>* AsyncListFieldsOfTableRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldsOfTableResponse>* PrepareAsyncListFieldsOfTableRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>* AsyncListDataResourceTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDataResourceTypesResponse>* PrepareAsyncListDataResourceTypesRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>* AsyncListMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListMapsResponse>* PrepareAsyncListMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListMapsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Map>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::smart3dmap::v1::Layer>* ListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request) override;
    ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>* AsyncListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::smart3dmap::v1::Layer>* PrepareAsyncListLayersOfMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>* AsyncListLayersOfMapByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListLayersOfMapByPageResponse>* PrepareAsyncListLayersOfMapByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>* AsyncGetRasterLayerDataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::RasterLayerData>* PrepareAsyncGetRasterLayerDataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>* AsyncDeleteMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteMapResponse>* PrepareAsyncDeleteMapRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* AsyncListGeoSurveyProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* PrepareAsyncListGeoSurveyProjectsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>* AsyncGetGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>* PrepareAsyncGetGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>* AsyncListDrillsByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillsByPageResponse>* PrepareAsyncListDrillsByPageRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::smart3dmap::v1::Drill>* ListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request) override;
    ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>* AsyncListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::smart3dmap::v1::Drill>* PrepareAsyncListDrillsByStreamRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>* AsyncGetDrillRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::Drill>* PrepareAsyncGetDrillRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>* AsyncGetDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillStdLayers>* PrepareAsyncGetDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>* AsyncGetDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DrillOriginalLayers>* PrepareAsyncGetDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GetDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>* AsyncListDillLogsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListDrillLogsResponse>* PrepareAsyncListDillLogsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListDrillLogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>* AsyncListSectionMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListSectionMapsResponse>* PrepareAsyncListSectionMapsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListSectionMapsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>* AsyncListStructureModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListStructureModelsResponse>* PrepareAsyncListStructureModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListStructureModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>* AsyncListFieldModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ListFieldModelsResponse>* PrepareAsyncListFieldModelsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ListFieldModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>* AsyncDeleteModelRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteModelResponse>* PrepareAsyncDeleteModelRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>* AsyncExportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ExportModelMetadataResponse>* PrepareAsyncExportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>* AsyncImportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportModelMetadataResponse>* PrepareAsyncImportModelMetadataRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>* AsyncCreateGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::GeoSurveyProject>* PrepareAsyncCreateGeoSurveyProjectRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::GeoSurveyProject& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* ImportDrillsByStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* AsyncImportDrillsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* PrepareAsyncImportDrillsByStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>* AsyncImportDrillsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillsResponse>* PrepareAsyncImportDrillsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillOriginalLayers& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillOriginalLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DrillStdLayers& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillStdLayersRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillWaterCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteDrillSoilCorrosivityRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteGeotechnicalRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportStdPenetrationRecordRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportStdPenetrationRecordRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteStdPenetrationRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteStdPenetrationRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* AsyncImportCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::ImportDrillDataStatus>* PrepareAsyncImportCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* AsyncDeleteCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::smart3dmap::v1::DeleteDrillDataResponse>* PrepareAsyncDeleteCompressiveResistanceRecordsRaw(::grpc::ClientContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListDBServerTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateDatabaseServer_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDatabaseServers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDatabaseServer_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateDatabaseServer_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDatabaseServer_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDatabaseAppTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateDatabase_;
    const ::grpc::internal::RpcMethod rpcmethod_AddExistingDatabase_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDatabases_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDatabase_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDatabase_;
    const ::grpc::internal::RpcMethod rpcmethod_ListProjects_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateProject_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProject_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateProject_;
    const ::grpc::internal::RpcMethod rpcmethod_PublishProject_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteProject_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateStdStrat_;
    const ::grpc::internal::RpcMethod rpcmethod_ListStdStrats_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStdStrat_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateStdStrat_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetStdStratItems_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteStdStrat_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportStdStratItemsByStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportStdStratItems_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDicTableCategories_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDicTables_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDicTableFields_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigTableFieldMap_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTablesInDB_;
    const ::grpc::internal::RpcMethod rpcmethod_ListFieldsOfTable_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDataResourceTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMaps_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMap_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLayersOfMap_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLayersOfMapByPage_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRasterLayerData_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteMap_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGeoSurveyProjects_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGeoSurveyProject_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDrillsByPage_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDrillsByStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDrill_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDrillStdLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDrillOriginalLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDillLogs_;
    const ::grpc::internal::RpcMethod rpcmethod_ListSectionMaps_;
    const ::grpc::internal::RpcMethod rpcmethod_ListStructureModels_;
    const ::grpc::internal::RpcMethod rpcmethod_ListFieldModels_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteModel_;
    const ::grpc::internal::RpcMethod rpcmethod_ExportModelMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportModelMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateGeoSurveyProject_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrillsByStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrills_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrillOriginalLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDrillOriginalLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrillStdLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDrillStdLayers_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrillWaterCorrosivity_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDrillWaterCorrosivity_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportDrillSoilCorrosivity_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteDrillSoilCorrosivity_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportGeotechnicalRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteGeotechnicalRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportStdPenetrationRecord_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteStdPenetrationRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportCompressiveResistanceRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteCompressiveResistanceRecords_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 查询支持的数据库服务器类型信息
    virtual ::grpc::Status ListDBServerTypes(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response);
    // 添加数据库服务器
    virtual ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response);
    // 获取可用的数据库服务器列表
    virtual ::grpc::Status ListDatabaseServers(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response);
    // 获取指定的数据库服务器的详细信息。
    virtual ::grpc::Status GetDatabaseServer(::grpc::ServerContext* context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response);
    // 修改指定的数据库服务器的信息。
    virtual ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response);
    // 删除指定的数据库服务器。仅该数据库服务器没有关联任何数据库时才可被删除。
    virtual ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response);
    // 查询业务数据库的分类信息
    virtual ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response);
    // 创建业务数据库
    virtual ::grpc::Status CreateDatabase(::grpc::ServerContext* context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response);
    // 添加已有的业务数据库。对该数据库，系统不执行创建表的过程，而使用库中已有的表。用户需保证库表结构确实符合系统规范。
    virtual ::grpc::Status AddExistingDatabase(::grpc::ServerContext* context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response);
    // 获取业务数据库列表
    virtual ::grpc::Status ListDatabases(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response);
    // 获取指定业务数据库的信息
    virtual ::grpc::Status GetDatabase(::grpc::ServerContext* context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response);
    // 删除业务数据库。仅删除关于该库的记录，不删除数据库的物理数据。
    virtual ::grpc::Status DeleteDatabase(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response);
    // 查询工程列表
    virtual ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response);
    // 创建工程
    virtual ::grpc::Status CreateProject(::grpc::ServerContext* context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response);
    // 根据ID查询指定的工程
    virtual ::grpc::Status GetProject(::grpc::ServerContext* context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response);
    // 修改指定的工程
    virtual ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response);
    // 发布工程或撤销已发布的工程
    virtual ::grpc::Status PublishProject(::grpc::ServerContext* context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response);
    // 根据ID删除指定的工程
    virtual ::grpc::Status DeleteProject(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response);
    // 标准地层组
    // 创建一个标准地层组
    virtual ::grpc::Status CreateStdStrat(::grpc::ServerContext* context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response);
    // 查询标准地层组及其概要信息（不含具体的分层）
    virtual ::grpc::Status ListStdStrats(::grpc::ServerContext* context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response);
    // 获取指定地层组的详细信息（含具体分层信息）
    virtual ::grpc::Status GetStdStrat(::grpc::ServerContext* context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response);
    // 修改指定地层组的概要信息
    virtual ::grpc::Status UpdateStdStrat(::grpc::ServerContext* context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response);
    // 更新标准地层组中的具体分层信息：一次性全部更新。
    virtual ::grpc::Status ResetStdStratItems(::grpc::ServerContext* context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response);
    // 删除指定的标准地层组
    virtual ::grpc::Status DeleteStdStrat(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response);
    // 逐条导入标准地层的分层记录。每导入一条分层记录均返回对应的操作状态。
    virtual ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* stream);
    // 批量导入标准地层的分层记录。要么都成功，要么都失败。
    virtual ::grpc::Status ImportStdStratItems(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response);
    // 数据字典：表分类
    virtual ::grpc::Status ListDicTableCategories(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response);
    // 数据字典：表映射信息
    virtual ::grpc::Status ListDicTables(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response);
    // 数据字典：表及其字段的映射信息
    virtual ::grpc::Status ListDicTableFields(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response);
    // 数据字典：配置表和字段映射
    virtual ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response);
    // 获取数据库中的表的列表
    virtual ::grpc::Status ListTablesInDB(::grpc::ServerContext* context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response);
    // 获取表的字段的列表
    virtual ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response);
    // 获取数据资源类型列表
    virtual ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response);
    // 获取二维地图列表
    virtual ::grpc::Status ListMaps(::grpc::ServerContext* context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response);
    // 获取二维地图信息
    virtual ::grpc::Status GetMap(::grpc::ServerContext* context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response);
    // 获取二维地图中的图层
    virtual ::grpc::Status ListLayersOfMap(::grpc::ServerContext* context, const ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* writer);
    virtual ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response);
    // 获取指定栅格图层的数据
    virtual ::grpc::Status GetRasterLayerData(::grpc::ServerContext* context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response);
    // 删除指定的地图。需要提前从MapService中撤销发布该地图。
    virtual ::grpc::Status DeleteMap(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response);
    // 查询地质调查工程/项目列表
    virtual ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response);
    // 获取指定地质调查项目的信息
    virtual ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response);
    // 分页查询指定数据库中的钻孔
    virtual ::grpc::Status ListDrillsByPage(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response);
    // 流式查询指定数据库中的钻孔
    virtual ::grpc::Status ListDrillsByStream(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* writer);
    // 查询指定钻孔的基本信息
    virtual ::grpc::Status GetDrill(::grpc::ServerContext* context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response);
    // 获取指定钻孔的标准分层信息
    virtual ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response);
    // 获取指定钻孔的原始分层信息
    virtual ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response);
    // 分页查询钻孔柱状图列表
    virtual ::grpc::Status ListDillLogs(::grpc::ServerContext* context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response);
    // 分页查询剖面图列表
    virtual ::grpc::Status ListSectionMaps(::grpc::ServerContext* context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response);
    // 分页查询三维结构模型列表
    virtual ::grpc::Status ListStructureModels(::grpc::ServerContext* context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response);
    // 分页查询三维属性模型列表
    virtual ::grpc::Status ListFieldModels(::grpc::ServerContext* context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response);
    // 删除指定的模型。
    virtual ::grpc::Status DeleteModel(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response);
    // 导出三维地质模型的元数据（仅支持XML文件格式）。导出的数据可作为模板用于编辑更新模型的元数据。
    virtual ::grpc::Status ExportModelMetadata(::grpc::ServerContext* context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response);
    // 导入三维地质模型的元数据（仅支持XML文件格式）。按导入的数据完整更新三维地质模型的元数据。
    virtual ::grpc::Status ImportModelMetadata(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response);
    // 钻孔数据入库
    // 新增地质调查工程/项目记录
    virtual ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response);
    // 新增钻孔记录。每导入一个钻孔记录都返回其对应的操作结果。
    virtual ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* stream);
    // 批量导入钻孔记录。要么都成功，要么都失败。
    virtual ::grpc::Status ImportDrills(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response);
    // 导入钻孔的原始分层信息
    virtual ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔的原始分层信息
    virtual ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入钻孔的标准分层信息
    virtual ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔的标准分层信息
    virtual ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入水腐蚀性分析记录。
    virtual ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔的水腐蚀性分析记录。
    virtual ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入土腐蚀性分析记录。
    virtual ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔的土腐蚀性分析记录。
    virtual ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入土工实验数据。
    virtual ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔的土工试验数据。
    virtual ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入标贯实验数据。
    virtual ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔标贯实验数据。
    virtual ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
    // 导入钻孔抗压强度试验数据
    virtual ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response);
    // 删除钻孔抗压强度试验数据。
    virtual ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDBServerTypes() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDBServerTypes(::grpc::ServerContext* context, ::smart3dmap::v1::ListDBServerTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDBServerTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateDatabaseServer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDatabaseServer(::grpc::ServerContext* context, ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DBServer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDatabaseServers() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabaseServers(::grpc::ServerContext* context, ::smart3dmap::v1::ListDatabaseServersRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDatabaseServersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDatabaseServer() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatabaseServer(::grpc::ServerContext* context, ::smart3dmap::v1::GetDatabaseServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DBServer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateDatabaseServer() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateDatabaseServer(::grpc::ServerContext* context, ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::UpdateDatabaseServerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDatabaseServer() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDatabaseServer(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDatabaseServerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDatabaseAppTypes() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabaseAppTypes(::grpc::ServerContext* context, ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDatabaseAppTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateDatabase() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDatabase(::grpc::ServerContext* context, ::smart3dmap::v1::CreateDatabaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Database>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddExistingDatabase() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddExistingDatabase(::grpc::ServerContext* context, ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Database>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDatabases() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabases(::grpc::ServerContext* context, ::smart3dmap::v1::ListDatabasesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDatabasesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDatabase() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatabase(::grpc::ServerContext* context, ::smart3dmap::v1::GetDatabaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Database>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDatabase() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDatabase(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDatabaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDatabaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListProjects() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListProjects(::grpc::ServerContext* context, ::smart3dmap::v1::ListProjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListProjectsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateProject() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProject(::grpc::ServerContext* context, ::smart3dmap::v1::CreateProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Project>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProject() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProject(::grpc::ServerContext* context, ::smart3dmap::v1::GetProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Project>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateProject() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProject(::grpc::ServerContext* context, ::smart3dmap::v1::UpdateProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::UpdateProjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PublishProject() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishProject(::grpc::ServerContext* context, ::smart3dmap::v1::PublishProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::PublishProjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteProject() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProject(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteProjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateStdStrat() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateStdStrat(::grpc::ServerContext* context, ::smart3dmap::v1::CreateStdStratRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::StdStrat>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListStdStrats() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStdStrats(::grpc::ServerContext* context, ::smart3dmap::v1::ListStdStratsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListStdStratsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStdStrat() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStdStrat(::grpc::ServerContext* context, ::smart3dmap::v1::GetStdStratRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::StdStrat>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateStdStrat() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStdStrat(::grpc::ServerContext* context, ::smart3dmap::v1::UpdateStdStratRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::UpdateStdStratResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetStdStratItems() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetStdStratItems(::grpc::ServerContext* context, ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ResetStdStratItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteStdStrat() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStdStrat(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteStdStratRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteStdStratResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportStdStratItemsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportStdStratItemsByStream() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ImportStdStratItemsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdStratItemsByStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(24, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportStdStratItems() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdStratItems(::grpc::ServerContext* context, ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportStdStratItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDicTableCategories() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTableCategories(::grpc::ServerContext* context, ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDicTableCategoriesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDicTables() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTables(::grpc::ServerContext* context, ::smart3dmap::v1::ListDicTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDicTablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDicTableFields() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTableFields(::grpc::ServerContext* context, ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDicTableFieldsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConfigTableFieldMap() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigTableFieldMap(::grpc::ServerContext* context, ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ConfigTableFieldMapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTablesInDB() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTablesInDB(::grpc::ServerContext* context, ::smart3dmap::v1::ListTablesInDBRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListTablesInDBResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListFieldsOfTable() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFieldsOfTable(::grpc::ServerContext* context, ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListFieldsOfTableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDataResourceTypes() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDataResourceTypes(::grpc::ServerContext* context, ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDataResourceTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListMaps() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMaps(::grpc::ServerContext* context, ::smart3dmap::v1::ListMapsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListMapsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMap() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMap(::grpc::ServerContext* context, ::smart3dmap::v1::GetMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Map>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLayersOfMap() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLayersOfMap(::grpc::ServerContext* context, ::smart3dmap::v1::ListLayersOfMapRequest* request, ::grpc::ServerAsyncWriter< ::smart3dmap::v1::Layer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLayersOfMapByPage() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLayersOfMapByPage(::grpc::ServerContext* context, ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListLayersOfMapByPageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRasterLayerData() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRasterLayerData(::grpc::ServerContext* context, ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::RasterLayerData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteMap() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMap(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteMapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListGeoSurveyProjects() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGeoSurveyProjects(::grpc::ServerContext* context, ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGeoSurveyProject() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGeoSurveyProject(::grpc::ServerContext* context, ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::GeoSurveyProject>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDrillsByPage() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrillsByPage(::grpc::ServerContext* context, ::smart3dmap::v1::ListDrillsByPageRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDrillsByPageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDrillsByStream() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrillsByStream(::grpc::ServerContext* context, ::smart3dmap::v1::ListDrillsByStreamRequest* request, ::grpc::ServerAsyncWriter< ::smart3dmap::v1::Drill>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDrill() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrill(::grpc::ServerContext* context, ::smart3dmap::v1::GetDrillRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::Drill>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDrillStdLayers() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrillStdLayers(::grpc::ServerContext* context, ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DrillStdLayers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDrillOriginalLayers() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrillOriginalLayers(::grpc::ServerContext* context, ::smart3dmap::v1::GetDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DrillOriginalLayers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDillLogs() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDillLogs(::grpc::ServerContext* context, ::smart3dmap::v1::ListDrillLogsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListDrillLogsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListSectionMaps() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSectionMaps(::grpc::ServerContext* context, ::smart3dmap::v1::ListSectionMapsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListSectionMapsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListStructureModels() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStructureModels(::grpc::ServerContext* context, ::smart3dmap::v1::ListStructureModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListStructureModelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListFieldModels() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFieldModels(::grpc::ServerContext* context, ::smart3dmap::v1::ListFieldModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ListFieldModelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteModel() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModel(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExportModelMetadata() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportModelMetadata(::grpc::ServerContext* context, ::smart3dmap::v1::ExportModelMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ExportModelMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportModelMetadata() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportModelMetadata(::grpc::ServerContext* context, ::smart3dmap::v1::ImportModelMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportModelMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateGeoSurveyProject() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGeoSurveyProject(::grpc::ServerContext* context, ::smart3dmap::v1::GeoSurveyProject* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::GeoSurveyProject>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrillsByStream() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_ImportDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillsByStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(54, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrills() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrills(::grpc::ServerContext* context, ::smart3dmap::v1::ImportDrillsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrillOriginalLayers() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillOriginalLayers(::grpc::ServerContext* context, ::smart3dmap::v1::DrillOriginalLayers* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDrillOriginalLayers() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillOriginalLayers(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrillStdLayers() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillStdLayers(::grpc::ServerContext* context, ::smart3dmap::v1::DrillStdLayers* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDrillStdLayers() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillStdLayers(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillWaterCorrosivity(::grpc::ServerContext* context, ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillWaterCorrosivity(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillSoilCorrosivity(::grpc::ServerContext* context, ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillSoilCorrosivity(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportGeotechnicalRecords() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportGeotechnicalRecords(::grpc::ServerContext* context, ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteGeotechnicalRecords() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGeotechnicalRecords(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportStdPenetrationRecord() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdPenetrationRecord(::grpc::ServerContext* context, ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteStdPenetrationRecords() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStdPenetrationRecords(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportCompressiveResistanceRecords(::grpc::ServerContext* context, ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::ImportDrillDataStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCompressiveResistanceRecords(::grpc::ServerContext* context, ::smart3dmap::v1::DeleteDrillDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::smart3dmap::v1::DeleteDrillDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListDBServerTypes<WithAsyncMethod_CreateDatabaseServer<WithAsyncMethod_ListDatabaseServers<WithAsyncMethod_GetDatabaseServer<WithAsyncMethod_UpdateDatabaseServer<WithAsyncMethod_DeleteDatabaseServer<WithAsyncMethod_ListDatabaseAppTypes<WithAsyncMethod_CreateDatabase<WithAsyncMethod_AddExistingDatabase<WithAsyncMethod_ListDatabases<WithAsyncMethod_GetDatabase<WithAsyncMethod_DeleteDatabase<WithAsyncMethod_ListProjects<WithAsyncMethod_CreateProject<WithAsyncMethod_GetProject<WithAsyncMethod_UpdateProject<WithAsyncMethod_PublishProject<WithAsyncMethod_DeleteProject<WithAsyncMethod_CreateStdStrat<WithAsyncMethod_ListStdStrats<WithAsyncMethod_GetStdStrat<WithAsyncMethod_UpdateStdStrat<WithAsyncMethod_ResetStdStratItems<WithAsyncMethod_DeleteStdStrat<WithAsyncMethod_ImportStdStratItemsByStream<WithAsyncMethod_ImportStdStratItems<WithAsyncMethod_ListDicTableCategories<WithAsyncMethod_ListDicTables<WithAsyncMethod_ListDicTableFields<WithAsyncMethod_ConfigTableFieldMap<WithAsyncMethod_ListTablesInDB<WithAsyncMethod_ListFieldsOfTable<WithAsyncMethod_ListDataResourceTypes<WithAsyncMethod_ListMaps<WithAsyncMethod_GetMap<WithAsyncMethod_ListLayersOfMap<WithAsyncMethod_ListLayersOfMapByPage<WithAsyncMethod_GetRasterLayerData<WithAsyncMethod_DeleteMap<WithAsyncMethod_ListGeoSurveyProjects<WithAsyncMethod_GetGeoSurveyProject<WithAsyncMethod_ListDrillsByPage<WithAsyncMethod_ListDrillsByStream<WithAsyncMethod_GetDrill<WithAsyncMethod_GetDrillStdLayers<WithAsyncMethod_GetDrillOriginalLayers<WithAsyncMethod_ListDillLogs<WithAsyncMethod_ListSectionMaps<WithAsyncMethod_ListStructureModels<WithAsyncMethod_ListFieldModels<WithAsyncMethod_DeleteModel<WithAsyncMethod_ExportModelMetadata<WithAsyncMethod_ImportModelMetadata<WithAsyncMethod_CreateGeoSurveyProject<WithAsyncMethod_ImportDrillsByStream<WithAsyncMethod_ImportDrills<WithAsyncMethod_ImportDrillOriginalLayers<WithAsyncMethod_DeleteDrillOriginalLayers<WithAsyncMethod_ImportDrillStdLayers<WithAsyncMethod_DeleteDrillStdLayers<WithAsyncMethod_ImportDrillWaterCorrosivity<WithAsyncMethod_DeleteDrillWaterCorrosivity<WithAsyncMethod_ImportDrillSoilCorrosivity<WithAsyncMethod_DeleteDrillSoilCorrosivity<WithAsyncMethod_ImportGeotechnicalRecords<WithAsyncMethod_DeleteGeotechnicalRecords<WithAsyncMethod_ImportStdPenetrationRecord<WithAsyncMethod_DeleteStdPenetrationRecords<WithAsyncMethod_ImportCompressiveResistanceRecords<WithAsyncMethod_DeleteCompressiveResistanceRecords<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDBServerTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDBServerTypesRequest, ::smart3dmap::v1::ListDBServerTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDBServerTypesRequest* request, ::smart3dmap::v1::ListDBServerTypesResponse* response) { return this->ListDBServerTypes(context, request, response); }));}
    void SetMessageAllocatorFor_ListDBServerTypes(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDBServerTypesRequest, ::smart3dmap::v1::ListDBServerTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDBServerTypesRequest, ::smart3dmap::v1::ListDBServerTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDBServerTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDBServerTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateDatabaseServerRequest, ::smart3dmap::v1::DBServer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::CreateDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response) { return this->CreateDatabaseServer(context, request, response); }));}
    void SetMessageAllocatorFor_CreateDatabaseServer(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::CreateDatabaseServerRequest, ::smart3dmap::v1::DBServer>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateDatabaseServerRequest, ::smart3dmap::v1::DBServer>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDatabaseServers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabaseServersRequest, ::smart3dmap::v1::ListDatabaseServersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDatabaseServersRequest* request, ::smart3dmap::v1::ListDatabaseServersResponse* response) { return this->ListDatabaseServers(context, request, response); }));}
    void SetMessageAllocatorFor_ListDatabaseServers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDatabaseServersRequest, ::smart3dmap::v1::ListDatabaseServersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabaseServersRequest, ::smart3dmap::v1::ListDatabaseServersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabaseServers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabaseServers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDatabaseServerRequest, ::smart3dmap::v1::DBServer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetDatabaseServerRequest* request, ::smart3dmap::v1::DBServer* response) { return this->GetDatabaseServer(context, request, response); }));}
    void SetMessageAllocatorFor_GetDatabaseServer(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetDatabaseServerRequest, ::smart3dmap::v1::DBServer>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDatabaseServerRequest, ::smart3dmap::v1::DBServer>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateDatabaseServerRequest, ::smart3dmap::v1::UpdateDatabaseServerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::UpdateDatabaseServerRequest* request, ::smart3dmap::v1::UpdateDatabaseServerResponse* response) { return this->UpdateDatabaseServer(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateDatabaseServer(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::UpdateDatabaseServerRequest, ::smart3dmap::v1::UpdateDatabaseServerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateDatabaseServerRequest, ::smart3dmap::v1::UpdateDatabaseServerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDatabaseServerRequest, ::smart3dmap::v1::DeleteDatabaseServerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDatabaseServerRequest* request, ::smart3dmap::v1::DeleteDatabaseServerResponse* response) { return this->DeleteDatabaseServer(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDatabaseServer(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDatabaseServerRequest, ::smart3dmap::v1::DeleteDatabaseServerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDatabaseServerRequest, ::smart3dmap::v1::DeleteDatabaseServerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDatabaseAppTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabaseAppTypesRequest, ::smart3dmap::v1::ListDatabaseAppTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* request, ::smart3dmap::v1::ListDatabaseAppTypesResponse* response) { return this->ListDatabaseAppTypes(context, request, response); }));}
    void SetMessageAllocatorFor_ListDatabaseAppTypes(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDatabaseAppTypesRequest, ::smart3dmap::v1::ListDatabaseAppTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabaseAppTypesRequest, ::smart3dmap::v1::ListDatabaseAppTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabaseAppTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabaseAppTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::CreateDatabaseRequest* request, ::smart3dmap::v1::Database* response) { return this->CreateDatabase(context, request, response); }));}
    void SetMessageAllocatorFor_CreateDatabase(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::CreateDatabaseRequest, ::smart3dmap::v1::Database>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateDatabaseRequest, ::smart3dmap::v1::Database>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddExistingDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::AddExistingDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::AddExistingDatabaseRequest* request, ::smart3dmap::v1::Database* response) { return this->AddExistingDatabase(context, request, response); }));}
    void SetMessageAllocatorFor_AddExistingDatabase(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::AddExistingDatabaseRequest, ::smart3dmap::v1::Database>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::AddExistingDatabaseRequest, ::smart3dmap::v1::Database>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddExistingDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddExistingDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDatabases() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabasesRequest, ::smart3dmap::v1::ListDatabasesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDatabasesRequest* request, ::smart3dmap::v1::ListDatabasesResponse* response) { return this->ListDatabases(context, request, response); }));}
    void SetMessageAllocatorFor_ListDatabases(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDatabasesRequest, ::smart3dmap::v1::ListDatabasesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDatabasesRequest, ::smart3dmap::v1::ListDatabasesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabases(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabases(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetDatabaseRequest* request, ::smart3dmap::v1::Database* response) { return this->GetDatabase(context, request, response); }));}
    void SetMessageAllocatorFor_GetDatabase(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetDatabaseRequest, ::smart3dmap::v1::Database>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDatabaseRequest, ::smart3dmap::v1::Database>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDatabaseRequest, ::smart3dmap::v1::DeleteDatabaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDatabaseRequest* request, ::smart3dmap::v1::DeleteDatabaseResponse* response) { return this->DeleteDatabase(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDatabase(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDatabaseRequest, ::smart3dmap::v1::DeleteDatabaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDatabaseRequest, ::smart3dmap::v1::DeleteDatabaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListProjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListProjectsRequest, ::smart3dmap::v1::ListProjectsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListProjectsRequest* request, ::smart3dmap::v1::ListProjectsResponse* response) { return this->ListProjects(context, request, response); }));}
    void SetMessageAllocatorFor_ListProjects(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListProjectsRequest, ::smart3dmap::v1::ListProjectsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListProjectsRequest, ::smart3dmap::v1::ListProjectsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListProjects(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListProjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateProjectRequest, ::smart3dmap::v1::Project>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::CreateProjectRequest* request, ::smart3dmap::v1::Project* response) { return this->CreateProject(context, request, response); }));}
    void SetMessageAllocatorFor_CreateProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::CreateProjectRequest, ::smart3dmap::v1::Project>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateProjectRequest, ::smart3dmap::v1::Project>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetProjectRequest, ::smart3dmap::v1::Project>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetProjectRequest* request, ::smart3dmap::v1::Project* response) { return this->GetProject(context, request, response); }));}
    void SetMessageAllocatorFor_GetProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetProjectRequest, ::smart3dmap::v1::Project>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetProjectRequest, ::smart3dmap::v1::Project>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateProjectRequest, ::smart3dmap::v1::UpdateProjectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::UpdateProjectRequest* request, ::smart3dmap::v1::UpdateProjectResponse* response) { return this->UpdateProject(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::UpdateProjectRequest, ::smart3dmap::v1::UpdateProjectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateProjectRequest, ::smart3dmap::v1::UpdateProjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PublishProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::PublishProjectRequest, ::smart3dmap::v1::PublishProjectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::PublishProjectRequest* request, ::smart3dmap::v1::PublishProjectResponse* response) { return this->PublishProject(context, request, response); }));}
    void SetMessageAllocatorFor_PublishProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::PublishProjectRequest, ::smart3dmap::v1::PublishProjectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::PublishProjectRequest, ::smart3dmap::v1::PublishProjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PublishProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PublishProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteProjectRequest, ::smart3dmap::v1::DeleteProjectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteProjectRequest* request, ::smart3dmap::v1::DeleteProjectResponse* response) { return this->DeleteProject(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteProjectRequest, ::smart3dmap::v1::DeleteProjectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteProjectRequest, ::smart3dmap::v1::DeleteProjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateStdStratRequest, ::smart3dmap::v1::StdStrat>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::CreateStdStratRequest* request, ::smart3dmap::v1::StdStrat* response) { return this->CreateStdStrat(context, request, response); }));}
    void SetMessageAllocatorFor_CreateStdStrat(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::CreateStdStratRequest, ::smart3dmap::v1::StdStrat>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::CreateStdStratRequest, ::smart3dmap::v1::StdStrat>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListStdStrats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListStdStratsRequest, ::smart3dmap::v1::ListStdStratsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListStdStratsRequest* request, ::smart3dmap::v1::ListStdStratsResponse* response) { return this->ListStdStrats(context, request, response); }));}
    void SetMessageAllocatorFor_ListStdStrats(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListStdStratsRequest, ::smart3dmap::v1::ListStdStratsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListStdStratsRequest, ::smart3dmap::v1::ListStdStratsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStdStrats(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStdStrats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetStdStratRequest, ::smart3dmap::v1::StdStrat>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetStdStratRequest* request, ::smart3dmap::v1::StdStrat* response) { return this->GetStdStrat(context, request, response); }));}
    void SetMessageAllocatorFor_GetStdStrat(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetStdStratRequest, ::smart3dmap::v1::StdStrat>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetStdStratRequest, ::smart3dmap::v1::StdStrat>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateStdStratRequest, ::smart3dmap::v1::UpdateStdStratResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::UpdateStdStratRequest* request, ::smart3dmap::v1::UpdateStdStratResponse* response) { return this->UpdateStdStrat(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateStdStrat(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::UpdateStdStratRequest, ::smart3dmap::v1::UpdateStdStratResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::UpdateStdStratRequest, ::smart3dmap::v1::UpdateStdStratResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResetStdStratItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ResetStdStratItemsRequest, ::smart3dmap::v1::ResetStdStratItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ResetStdStratItemsRequest* request, ::smart3dmap::v1::ResetStdStratItemsResponse* response) { return this->ResetStdStratItems(context, request, response); }));}
    void SetMessageAllocatorFor_ResetStdStratItems(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ResetStdStratItemsRequest, ::smart3dmap::v1::ResetStdStratItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ResetStdStratItemsRequest, ::smart3dmap::v1::ResetStdStratItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResetStdStratItems(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResetStdStratItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteStdStratRequest, ::smart3dmap::v1::DeleteStdStratResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteStdStratRequest* request, ::smart3dmap::v1::DeleteStdStratResponse* response) { return this->DeleteStdStrat(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteStdStrat(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteStdStratRequest, ::smart3dmap::v1::DeleteStdStratResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteStdStratRequest, ::smart3dmap::v1::DeleteStdStratResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportStdStratItemsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportStdStratItemsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackBidiHandler< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ImportStdStratItemsByStream(context); }));
    }
    ~ExperimentalWithCallbackMethod_ImportStdStratItemsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* ImportStdStratItemsByStream(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::smart3dmap::v1::ImportedStdStratItem, ::smart3dmap::v1::ImportStdStratItemStatus>* ImportStdStratItemsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportStdStratItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportStdStratItemsRequest, ::smart3dmap::v1::ImportStdStratItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportStdStratItemsRequest* request, ::smart3dmap::v1::ImportStdStratItemsResponse* response) { return this->ImportStdStratItems(context, request, response); }));}
    void SetMessageAllocatorFor_ImportStdStratItems(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportStdStratItemsRequest, ::smart3dmap::v1::ImportStdStratItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportStdStratItemsRequest, ::smart3dmap::v1::ImportStdStratItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportStdStratItems(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportStdStratItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDicTableCategories() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTableCategoriesRequest, ::smart3dmap::v1::ListDicTableCategoriesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDicTableCategoriesRequest* request, ::smart3dmap::v1::ListDicTableCategoriesResponse* response) { return this->ListDicTableCategories(context, request, response); }));}
    void SetMessageAllocatorFor_ListDicTableCategories(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDicTableCategoriesRequest, ::smart3dmap::v1::ListDicTableCategoriesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTableCategoriesRequest, ::smart3dmap::v1::ListDicTableCategoriesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTableCategories(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTableCategories(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDicTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTablesRequest, ::smart3dmap::v1::ListDicTablesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDicTablesRequest* request, ::smart3dmap::v1::ListDicTablesResponse* response) { return this->ListDicTables(context, request, response); }));}
    void SetMessageAllocatorFor_ListDicTables(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDicTablesRequest, ::smart3dmap::v1::ListDicTablesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTablesRequest, ::smart3dmap::v1::ListDicTablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTables(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDicTableFields() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTableFieldsRequest, ::smart3dmap::v1::ListDicTableFieldsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDicTableFieldsRequest* request, ::smart3dmap::v1::ListDicTableFieldsResponse* response) { return this->ListDicTableFields(context, request, response); }));}
    void SetMessageAllocatorFor_ListDicTableFields(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDicTableFieldsRequest, ::smart3dmap::v1::ListDicTableFieldsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDicTableFieldsRequest, ::smart3dmap::v1::ListDicTableFieldsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTableFields(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTableFields(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ConfigTableFieldMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ConfigTableFieldMapRequest, ::smart3dmap::v1::ConfigTableFieldMapResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ConfigTableFieldMapRequest* request, ::smart3dmap::v1::ConfigTableFieldMapResponse* response) { return this->ConfigTableFieldMap(context, request, response); }));}
    void SetMessageAllocatorFor_ConfigTableFieldMap(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ConfigTableFieldMapRequest, ::smart3dmap::v1::ConfigTableFieldMapResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ConfigTableFieldMapRequest, ::smart3dmap::v1::ConfigTableFieldMapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConfigTableFieldMap(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConfigTableFieldMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListTablesInDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListTablesInDBRequest, ::smart3dmap::v1::ListTablesInDBResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListTablesInDBRequest* request, ::smart3dmap::v1::ListTablesInDBResponse* response) { return this->ListTablesInDB(context, request, response); }));}
    void SetMessageAllocatorFor_ListTablesInDB(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListTablesInDBRequest, ::smart3dmap::v1::ListTablesInDBResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListTablesInDBRequest, ::smart3dmap::v1::ListTablesInDBResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTablesInDB(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTablesInDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListFieldsOfTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListFieldsOfTableRequest, ::smart3dmap::v1::ListFieldsOfTableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListFieldsOfTableRequest* request, ::smart3dmap::v1::ListFieldsOfTableResponse* response) { return this->ListFieldsOfTable(context, request, response); }));}
    void SetMessageAllocatorFor_ListFieldsOfTable(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListFieldsOfTableRequest, ::smart3dmap::v1::ListFieldsOfTableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListFieldsOfTableRequest, ::smart3dmap::v1::ListFieldsOfTableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFieldsOfTable(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFieldsOfTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDataResourceTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDataResourceTypesRequest, ::smart3dmap::v1::ListDataResourceTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDataResourceTypesRequest* request, ::smart3dmap::v1::ListDataResourceTypesResponse* response) { return this->ListDataResourceTypes(context, request, response); }));}
    void SetMessageAllocatorFor_ListDataResourceTypes(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDataResourceTypesRequest, ::smart3dmap::v1::ListDataResourceTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(32);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDataResourceTypesRequest, ::smart3dmap::v1::ListDataResourceTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDataResourceTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDataResourceTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListMaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListMapsRequest, ::smart3dmap::v1::ListMapsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListMapsRequest* request, ::smart3dmap::v1::ListMapsResponse* response) { return this->ListMaps(context, request, response); }));}
    void SetMessageAllocatorFor_ListMaps(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListMapsRequest, ::smart3dmap::v1::ListMapsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(33);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListMapsRequest, ::smart3dmap::v1::ListMapsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMaps(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetMapRequest, ::smart3dmap::v1::Map>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetMapRequest* request, ::smart3dmap::v1::Map* response) { return this->GetMap(context, request, response); }));}
    void SetMessageAllocatorFor_GetMap(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetMapRequest, ::smart3dmap::v1::Map>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(34);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetMapRequest, ::smart3dmap::v1::Map>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetMap(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLayersOfMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::smart3dmap::v1::ListLayersOfMapRequest, ::smart3dmap::v1::Layer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListLayersOfMapRequest* request) { return this->ListLayersOfMap(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::smart3dmap::v1::Layer>* ListLayersOfMap(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::smart3dmap::v1::Layer>* ListLayersOfMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLayersOfMapByPage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListLayersOfMapByPageRequest, ::smart3dmap::v1::ListLayersOfMapByPageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* request, ::smart3dmap::v1::ListLayersOfMapByPageResponse* response) { return this->ListLayersOfMapByPage(context, request, response); }));}
    void SetMessageAllocatorFor_ListLayersOfMapByPage(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListLayersOfMapByPageRequest, ::smart3dmap::v1::ListLayersOfMapByPageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(36);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListLayersOfMapByPageRequest, ::smart3dmap::v1::ListLayersOfMapByPageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLayersOfMapByPage(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLayersOfMapByPage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRasterLayerData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetRasterLayerDataRequest, ::smart3dmap::v1::RasterLayerData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetRasterLayerDataRequest* request, ::smart3dmap::v1::RasterLayerData* response) { return this->GetRasterLayerData(context, request, response); }));}
    void SetMessageAllocatorFor_GetRasterLayerData(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetRasterLayerDataRequest, ::smart3dmap::v1::RasterLayerData>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetRasterLayerDataRequest, ::smart3dmap::v1::RasterLayerData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRasterLayerData(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRasterLayerData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteMapRequest, ::smart3dmap::v1::DeleteMapResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteMapRequest* request, ::smart3dmap::v1::DeleteMapResponse* response) { return this->DeleteMap(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteMap(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteMapRequest, ::smart3dmap::v1::DeleteMapResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteMapRequest, ::smart3dmap::v1::DeleteMapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMap(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListGeoSurveyProjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListGeoSurveyProjectsRequest, ::smart3dmap::v1::ListGeoSurveyProjectsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* request, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* response) { return this->ListGeoSurveyProjects(context, request, response); }));}
    void SetMessageAllocatorFor_ListGeoSurveyProjects(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListGeoSurveyProjectsRequest, ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListGeoSurveyProjectsRequest, ::smart3dmap::v1::ListGeoSurveyProjectsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGeoSurveyProjects(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGeoSurveyProjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetGeoSurveyProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetGeoSurveyProjectRequest, ::smart3dmap::v1::GeoSurveyProject>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* request, ::smart3dmap::v1::GeoSurveyProject* response) { return this->GetGeoSurveyProject(context, request, response); }));}
    void SetMessageAllocatorFor_GetGeoSurveyProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetGeoSurveyProjectRequest, ::smart3dmap::v1::GeoSurveyProject>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(40);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetGeoSurveyProjectRequest, ::smart3dmap::v1::GeoSurveyProject>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetGeoSurveyProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetGeoSurveyProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDrillsByPage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDrillsByPageRequest, ::smart3dmap::v1::ListDrillsByPageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDrillsByPageRequest* request, ::smart3dmap::v1::ListDrillsByPageResponse* response) { return this->ListDrillsByPage(context, request, response); }));}
    void SetMessageAllocatorFor_ListDrillsByPage(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDrillsByPageRequest, ::smart3dmap::v1::ListDrillsByPageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(41);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDrillsByPageRequest, ::smart3dmap::v1::ListDrillsByPageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDrillsByPage(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDrillsByPage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDrillsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::smart3dmap::v1::ListDrillsByStreamRequest, ::smart3dmap::v1::Drill>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDrillsByStreamRequest* request) { return this->ListDrillsByStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::smart3dmap::v1::Drill>* ListDrillsByStream(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::smart3dmap::v1::Drill>* ListDrillsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDrill() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillRequest, ::smart3dmap::v1::Drill>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetDrillRequest* request, ::smart3dmap::v1::Drill* response) { return this->GetDrill(context, request, response); }));}
    void SetMessageAllocatorFor_GetDrill(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetDrillRequest, ::smart3dmap::v1::Drill>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(43);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillRequest, ::smart3dmap::v1::Drill>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrill(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrill(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillStdLayersRequest, ::smart3dmap::v1::DrillStdLayers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetDrillStdLayersRequest* request, ::smart3dmap::v1::DrillStdLayers* response) { return this->GetDrillStdLayers(context, request, response); }));}
    void SetMessageAllocatorFor_GetDrillStdLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetDrillStdLayersRequest, ::smart3dmap::v1::DrillStdLayers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(44);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillStdLayersRequest, ::smart3dmap::v1::DrillStdLayers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillDataRequest, ::smart3dmap::v1::DrillOriginalLayers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GetDrillDataRequest* request, ::smart3dmap::v1::DrillOriginalLayers* response) { return this->GetDrillOriginalLayers(context, request, response); }));}
    void SetMessageAllocatorFor_GetDrillOriginalLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GetDrillDataRequest, ::smart3dmap::v1::DrillOriginalLayers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(45);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GetDrillDataRequest, ::smart3dmap::v1::DrillOriginalLayers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListDillLogs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDrillLogsRequest, ::smart3dmap::v1::ListDrillLogsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListDrillLogsRequest* request, ::smart3dmap::v1::ListDrillLogsResponse* response) { return this->ListDillLogs(context, request, response); }));}
    void SetMessageAllocatorFor_ListDillLogs(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListDrillLogsRequest, ::smart3dmap::v1::ListDrillLogsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(46);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListDrillLogsRequest, ::smart3dmap::v1::ListDrillLogsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDillLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDillLogs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListSectionMaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListSectionMapsRequest, ::smart3dmap::v1::ListSectionMapsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListSectionMapsRequest* request, ::smart3dmap::v1::ListSectionMapsResponse* response) { return this->ListSectionMaps(context, request, response); }));}
    void SetMessageAllocatorFor_ListSectionMaps(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListSectionMapsRequest, ::smart3dmap::v1::ListSectionMapsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(47);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListSectionMapsRequest, ::smart3dmap::v1::ListSectionMapsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSectionMaps(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSectionMaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListStructureModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListStructureModelsRequest, ::smart3dmap::v1::ListStructureModelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListStructureModelsRequest* request, ::smart3dmap::v1::ListStructureModelsResponse* response) { return this->ListStructureModels(context, request, response); }));}
    void SetMessageAllocatorFor_ListStructureModels(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListStructureModelsRequest, ::smart3dmap::v1::ListStructureModelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(48);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListStructureModelsRequest, ::smart3dmap::v1::ListStructureModelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStructureModels(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStructureModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListFieldModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListFieldModelsRequest, ::smart3dmap::v1::ListFieldModelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ListFieldModelsRequest* request, ::smart3dmap::v1::ListFieldModelsResponse* response) { return this->ListFieldModels(context, request, response); }));}
    void SetMessageAllocatorFor_ListFieldModels(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ListFieldModelsRequest, ::smart3dmap::v1::ListFieldModelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(49);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ListFieldModelsRequest, ::smart3dmap::v1::ListFieldModelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFieldModels(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFieldModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteModelRequest, ::smart3dmap::v1::DeleteModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteModelRequest* request, ::smart3dmap::v1::DeleteModelResponse* response) { return this->DeleteModel(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteModel(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteModelRequest, ::smart3dmap::v1::DeleteModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(50);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteModelRequest, ::smart3dmap::v1::DeleteModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModel(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExportModelMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ExportModelMetadataRequest, ::smart3dmap::v1::ExportModelMetadataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ExportModelMetadataRequest* request, ::smart3dmap::v1::ExportModelMetadataResponse* response) { return this->ExportModelMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_ExportModelMetadata(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ExportModelMetadataRequest, ::smart3dmap::v1::ExportModelMetadataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ExportModelMetadataRequest, ::smart3dmap::v1::ExportModelMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportModelMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportModelMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportModelMetadataRequest, ::smart3dmap::v1::ImportModelMetadataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportModelMetadataRequest* request, ::smart3dmap::v1::ImportModelMetadataResponse* response) { return this->ImportModelMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_ImportModelMetadata(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportModelMetadataRequest, ::smart3dmap::v1::ImportModelMetadataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(52);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportModelMetadataRequest, ::smart3dmap::v1::ImportModelMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportModelMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateGeoSurveyProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GeoSurveyProject, ::smart3dmap::v1::GeoSurveyProject>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::GeoSurveyProject* request, ::smart3dmap::v1::GeoSurveyProject* response) { return this->CreateGeoSurveyProject(context, request, response); }));}
    void SetMessageAllocatorFor_CreateGeoSurveyProject(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::GeoSurveyProject, ::smart3dmap::v1::GeoSurveyProject>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(53);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::GeoSurveyProject, ::smart3dmap::v1::GeoSurveyProject>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGeoSurveyProject(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGeoSurveyProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrillsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc::internal::CallbackBidiHandler< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ImportDrillsByStream(context); }));
    }
    ~ExperimentalWithCallbackMethod_ImportDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* ImportDrillsByStream(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::smart3dmap::v1::Drill, ::smart3dmap::v1::ImportDrillStatus>* ImportDrillsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrills() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillsRequest, ::smart3dmap::v1::ImportDrillsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportDrillsRequest* request, ::smart3dmap::v1::ImportDrillsResponse* response) { return this->ImportDrills(context, request, response); }));}
    void SetMessageAllocatorFor_ImportDrills(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportDrillsRequest, ::smart3dmap::v1::ImportDrillsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(55);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillsRequest, ::smart3dmap::v1::ImportDrillsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrills(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrills(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DrillOriginalLayers, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DrillOriginalLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportDrillOriginalLayers(context, request, response); }));}
    void SetMessageAllocatorFor_ImportDrillOriginalLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DrillOriginalLayers, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(56);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DrillOriginalLayers, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteDrillOriginalLayers(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDrillOriginalLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(57);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DrillStdLayers, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DrillStdLayers* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportDrillStdLayers(context, request, response); }));}
    void SetMessageAllocatorFor_ImportDrillStdLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DrillStdLayers, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(58);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DrillStdLayers, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteDrillStdLayers(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDrillStdLayers(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(59);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrillWaterCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportDrillWaterCorrosivity(context, request, response); }));}
    void SetMessageAllocatorFor_ImportDrillWaterCorrosivity(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(60);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillWaterCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillWaterCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDrillWaterCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteDrillWaterCorrosivity(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDrillWaterCorrosivity(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(61);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillWaterCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillWaterCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportDrillSoilCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportDrillSoilCorrosivity(context, request, response); }));}
    void SetMessageAllocatorFor_ImportDrillSoilCorrosivity(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(62);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillSoilCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillSoilCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteDrillSoilCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteDrillSoilCorrosivity(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteDrillSoilCorrosivity(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(63);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillSoilCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillSoilCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportGeotechnicalRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportGeotechnicalRecordsRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportGeotechnicalRecords(context, request, response); }));}
    void SetMessageAllocatorFor_ImportGeotechnicalRecords(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportGeotechnicalRecordsRequest, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(64);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportGeotechnicalRecordsRequest, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportGeotechnicalRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportGeotechnicalRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteGeotechnicalRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteGeotechnicalRecords(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteGeotechnicalRecords(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(65);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGeotechnicalRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGeotechnicalRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportStdPenetrationRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportStdPenetrationRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportStdPenetrationRecord(context, request, response); }));}
    void SetMessageAllocatorFor_ImportStdPenetrationRecord(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportStdPenetrationRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(66);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportStdPenetrationRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportStdPenetrationRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportStdPenetrationRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteStdPenetrationRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteStdPenetrationRecords(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteStdPenetrationRecords(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(67);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStdPenetrationRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStdPenetrationRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportCompressiveResistanceRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* request, ::smart3dmap::v1::ImportDrillDataStatus* response) { return this->ImportCompressiveResistanceRecords(context, request, response); }));}
    void SetMessageAllocatorFor_ImportCompressiveResistanceRecords(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(68);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportCompressiveResistanceRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportCompressiveResistanceRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteCompressiveResistanceRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::smart3dmap::v1::DeleteDrillDataRequest* request, ::smart3dmap::v1::DeleteDrillDataResponse* response) { return this->DeleteCompressiveResistanceRecords(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteCompressiveResistanceRecords(
        ::grpc::experimental::MessageAllocator< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(69);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCompressiveResistanceRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCompressiveResistanceRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ListDBServerTypes<ExperimentalWithCallbackMethod_CreateDatabaseServer<ExperimentalWithCallbackMethod_ListDatabaseServers<ExperimentalWithCallbackMethod_GetDatabaseServer<ExperimentalWithCallbackMethod_UpdateDatabaseServer<ExperimentalWithCallbackMethod_DeleteDatabaseServer<ExperimentalWithCallbackMethod_ListDatabaseAppTypes<ExperimentalWithCallbackMethod_CreateDatabase<ExperimentalWithCallbackMethod_AddExistingDatabase<ExperimentalWithCallbackMethod_ListDatabases<ExperimentalWithCallbackMethod_GetDatabase<ExperimentalWithCallbackMethod_DeleteDatabase<ExperimentalWithCallbackMethod_ListProjects<ExperimentalWithCallbackMethod_CreateProject<ExperimentalWithCallbackMethod_GetProject<ExperimentalWithCallbackMethod_UpdateProject<ExperimentalWithCallbackMethod_PublishProject<ExperimentalWithCallbackMethod_DeleteProject<ExperimentalWithCallbackMethod_CreateStdStrat<ExperimentalWithCallbackMethod_ListStdStrats<ExperimentalWithCallbackMethod_GetStdStrat<ExperimentalWithCallbackMethod_UpdateStdStrat<ExperimentalWithCallbackMethod_ResetStdStratItems<ExperimentalWithCallbackMethod_DeleteStdStrat<ExperimentalWithCallbackMethod_ImportStdStratItemsByStream<ExperimentalWithCallbackMethod_ImportStdStratItems<ExperimentalWithCallbackMethod_ListDicTableCategories<ExperimentalWithCallbackMethod_ListDicTables<ExperimentalWithCallbackMethod_ListDicTableFields<ExperimentalWithCallbackMethod_ConfigTableFieldMap<ExperimentalWithCallbackMethod_ListTablesInDB<ExperimentalWithCallbackMethod_ListFieldsOfTable<ExperimentalWithCallbackMethod_ListDataResourceTypes<ExperimentalWithCallbackMethod_ListMaps<ExperimentalWithCallbackMethod_GetMap<ExperimentalWithCallbackMethod_ListLayersOfMap<ExperimentalWithCallbackMethod_ListLayersOfMapByPage<ExperimentalWithCallbackMethod_GetRasterLayerData<ExperimentalWithCallbackMethod_DeleteMap<ExperimentalWithCallbackMethod_ListGeoSurveyProjects<ExperimentalWithCallbackMethod_GetGeoSurveyProject<ExperimentalWithCallbackMethod_ListDrillsByPage<ExperimentalWithCallbackMethod_ListDrillsByStream<ExperimentalWithCallbackMethod_GetDrill<ExperimentalWithCallbackMethod_GetDrillStdLayers<ExperimentalWithCallbackMethod_GetDrillOriginalLayers<ExperimentalWithCallbackMethod_ListDillLogs<ExperimentalWithCallbackMethod_ListSectionMaps<ExperimentalWithCallbackMethod_ListStructureModels<ExperimentalWithCallbackMethod_ListFieldModels<ExperimentalWithCallbackMethod_DeleteModel<ExperimentalWithCallbackMethod_ExportModelMetadata<ExperimentalWithCallbackMethod_ImportModelMetadata<ExperimentalWithCallbackMethod_CreateGeoSurveyProject<ExperimentalWithCallbackMethod_ImportDrillsByStream<ExperimentalWithCallbackMethod_ImportDrills<ExperimentalWithCallbackMethod_ImportDrillOriginalLayers<ExperimentalWithCallbackMethod_DeleteDrillOriginalLayers<ExperimentalWithCallbackMethod_ImportDrillStdLayers<ExperimentalWithCallbackMethod_DeleteDrillStdLayers<ExperimentalWithCallbackMethod_ImportDrillWaterCorrosivity<ExperimentalWithCallbackMethod_DeleteDrillWaterCorrosivity<ExperimentalWithCallbackMethod_ImportDrillSoilCorrosivity<ExperimentalWithCallbackMethod_DeleteDrillSoilCorrosivity<ExperimentalWithCallbackMethod_ImportGeotechnicalRecords<ExperimentalWithCallbackMethod_DeleteGeotechnicalRecords<ExperimentalWithCallbackMethod_ImportStdPenetrationRecord<ExperimentalWithCallbackMethod_DeleteStdPenetrationRecords<ExperimentalWithCallbackMethod_ImportCompressiveResistanceRecords<ExperimentalWithCallbackMethod_DeleteCompressiveResistanceRecords<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ListDBServerTypes<ExperimentalWithCallbackMethod_CreateDatabaseServer<ExperimentalWithCallbackMethod_ListDatabaseServers<ExperimentalWithCallbackMethod_GetDatabaseServer<ExperimentalWithCallbackMethod_UpdateDatabaseServer<ExperimentalWithCallbackMethod_DeleteDatabaseServer<ExperimentalWithCallbackMethod_ListDatabaseAppTypes<ExperimentalWithCallbackMethod_CreateDatabase<ExperimentalWithCallbackMethod_AddExistingDatabase<ExperimentalWithCallbackMethod_ListDatabases<ExperimentalWithCallbackMethod_GetDatabase<ExperimentalWithCallbackMethod_DeleteDatabase<ExperimentalWithCallbackMethod_ListProjects<ExperimentalWithCallbackMethod_CreateProject<ExperimentalWithCallbackMethod_GetProject<ExperimentalWithCallbackMethod_UpdateProject<ExperimentalWithCallbackMethod_PublishProject<ExperimentalWithCallbackMethod_DeleteProject<ExperimentalWithCallbackMethod_CreateStdStrat<ExperimentalWithCallbackMethod_ListStdStrats<ExperimentalWithCallbackMethod_GetStdStrat<ExperimentalWithCallbackMethod_UpdateStdStrat<ExperimentalWithCallbackMethod_ResetStdStratItems<ExperimentalWithCallbackMethod_DeleteStdStrat<ExperimentalWithCallbackMethod_ImportStdStratItemsByStream<ExperimentalWithCallbackMethod_ImportStdStratItems<ExperimentalWithCallbackMethod_ListDicTableCategories<ExperimentalWithCallbackMethod_ListDicTables<ExperimentalWithCallbackMethod_ListDicTableFields<ExperimentalWithCallbackMethod_ConfigTableFieldMap<ExperimentalWithCallbackMethod_ListTablesInDB<ExperimentalWithCallbackMethod_ListFieldsOfTable<ExperimentalWithCallbackMethod_ListDataResourceTypes<ExperimentalWithCallbackMethod_ListMaps<ExperimentalWithCallbackMethod_GetMap<ExperimentalWithCallbackMethod_ListLayersOfMap<ExperimentalWithCallbackMethod_ListLayersOfMapByPage<ExperimentalWithCallbackMethod_GetRasterLayerData<ExperimentalWithCallbackMethod_DeleteMap<ExperimentalWithCallbackMethod_ListGeoSurveyProjects<ExperimentalWithCallbackMethod_GetGeoSurveyProject<ExperimentalWithCallbackMethod_ListDrillsByPage<ExperimentalWithCallbackMethod_ListDrillsByStream<ExperimentalWithCallbackMethod_GetDrill<ExperimentalWithCallbackMethod_GetDrillStdLayers<ExperimentalWithCallbackMethod_GetDrillOriginalLayers<ExperimentalWithCallbackMethod_ListDillLogs<ExperimentalWithCallbackMethod_ListSectionMaps<ExperimentalWithCallbackMethod_ListStructureModels<ExperimentalWithCallbackMethod_ListFieldModels<ExperimentalWithCallbackMethod_DeleteModel<ExperimentalWithCallbackMethod_ExportModelMetadata<ExperimentalWithCallbackMethod_ImportModelMetadata<ExperimentalWithCallbackMethod_CreateGeoSurveyProject<ExperimentalWithCallbackMethod_ImportDrillsByStream<ExperimentalWithCallbackMethod_ImportDrills<ExperimentalWithCallbackMethod_ImportDrillOriginalLayers<ExperimentalWithCallbackMethod_DeleteDrillOriginalLayers<ExperimentalWithCallbackMethod_ImportDrillStdLayers<ExperimentalWithCallbackMethod_DeleteDrillStdLayers<ExperimentalWithCallbackMethod_ImportDrillWaterCorrosivity<ExperimentalWithCallbackMethod_DeleteDrillWaterCorrosivity<ExperimentalWithCallbackMethod_ImportDrillSoilCorrosivity<ExperimentalWithCallbackMethod_DeleteDrillSoilCorrosivity<ExperimentalWithCallbackMethod_ImportGeotechnicalRecords<ExperimentalWithCallbackMethod_DeleteGeotechnicalRecords<ExperimentalWithCallbackMethod_ImportStdPenetrationRecord<ExperimentalWithCallbackMethod_DeleteStdPenetrationRecords<ExperimentalWithCallbackMethod_ImportCompressiveResistanceRecords<ExperimentalWithCallbackMethod_DeleteCompressiveResistanceRecords<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDBServerTypes() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateDatabaseServer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDatabaseServers() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDatabaseServer() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateDatabaseServer() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDatabaseServer() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDatabaseAppTypes() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateDatabase() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddExistingDatabase() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDatabases() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDatabase() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDatabase() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListProjects() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateProject() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProject() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateProject() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PublishProject() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteProject() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateStdStrat() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListStdStrats() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStdStrat() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateStdStrat() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetStdStratItems() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteStdStrat() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportStdStratItemsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportStdStratItemsByStream() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ImportStdStratItemsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportStdStratItems() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDicTableCategories() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDicTables() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDicTableFields() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConfigTableFieldMap() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTablesInDB() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListFieldsOfTable() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDataResourceTypes() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListMaps() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMap() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLayersOfMap() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLayersOfMapByPage() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRasterLayerData() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteMap() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListGeoSurveyProjects() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGeoSurveyProject() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDrillsByPage() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDrillsByStream() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDrill() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDrillStdLayers() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDrillOriginalLayers() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDillLogs() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListSectionMaps() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListStructureModels() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListFieldModels() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteModel() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExportModelMetadata() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportModelMetadata() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateGeoSurveyProject() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrillsByStream() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_ImportDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrills() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrillOriginalLayers() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDrillOriginalLayers() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrillStdLayers() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDrillStdLayers() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportGeotechnicalRecords() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteGeotechnicalRecords() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportStdPenetrationRecord() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteStdPenetrationRecords() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDBServerTypes() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDBServerTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateDatabaseServer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDatabaseServer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDatabaseServers() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabaseServers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDatabaseServer() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatabaseServer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateDatabaseServer() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateDatabaseServer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDatabaseServer() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDatabaseServer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDatabaseAppTypes() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabaseAppTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateDatabase() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDatabase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddExistingDatabase() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddExistingDatabase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDatabases() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDatabases(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDatabase() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatabase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDatabase() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDatabase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListProjects() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListProjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateProject() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProject() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateProject() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PublishProject() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteProject() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateStdStrat() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateStdStrat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListStdStrats() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStdStrats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStdStrat() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStdStrat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateStdStrat() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStdStrat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetStdStratItems() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetStdStratItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteStdStrat() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStdStrat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportStdStratItemsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportStdStratItemsByStream() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ImportStdStratItemsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdStratItemsByStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(24, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportStdStratItems() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdStratItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDicTableCategories() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTableCategories(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDicTables() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDicTableFields() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDicTableFields(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConfigTableFieldMap() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigTableFieldMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTablesInDB() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTablesInDB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListFieldsOfTable() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFieldsOfTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDataResourceTypes() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDataResourceTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListMaps() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMaps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMap() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLayersOfMap() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLayersOfMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLayersOfMapByPage() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLayersOfMapByPage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRasterLayerData() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRasterLayerData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteMap() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListGeoSurveyProjects() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGeoSurveyProjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGeoSurveyProject() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGeoSurveyProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDrillsByPage() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrillsByPage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDrillsByStream() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrillsByStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDrill() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrill(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDrillStdLayers() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrillStdLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDrillOriginalLayers() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDillLogs() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDillLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListSectionMaps() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSectionMaps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListStructureModels() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStructureModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListFieldModels() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFieldModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteModel() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExportModelMetadata() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportModelMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportModelMetadata() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportModelMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateGeoSurveyProject() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGeoSurveyProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrillsByStream() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_ImportDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillsByStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(54, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrills() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrills(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrillOriginalLayers() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDrillOriginalLayers() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrillStdLayers() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillStdLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDrillStdLayers() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillStdLayers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillWaterCorrosivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillWaterCorrosivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportDrillSoilCorrosivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteDrillSoilCorrosivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportGeotechnicalRecords() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportGeotechnicalRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteGeotechnicalRecords() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGeotechnicalRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportStdPenetrationRecord() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportStdPenetrationRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteStdPenetrationRecords() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStdPenetrationRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportCompressiveResistanceRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCompressiveResistanceRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDBServerTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDBServerTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDBServerTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDBServerTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateDatabaseServer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDatabaseServers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDatabaseServers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabaseServers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabaseServers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDatabaseServer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateDatabaseServer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDatabaseServer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDatabaseServer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDatabaseServer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDatabaseServer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDatabaseAppTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDatabaseAppTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabaseAppTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabaseAppTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateDatabase(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddExistingDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddExistingDatabase(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddExistingDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddExistingDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDatabases() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDatabases(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDatabases(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDatabases(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDatabase(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDatabase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDatabase(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDatabase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDatabase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListProjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListProjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListProjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListProjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PublishProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PublishProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PublishProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PublishProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateStdStrat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListStdStrats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListStdStrats(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStdStrats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStdStrats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStdStrat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateStdStrat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResetStdStratItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetStdStratItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResetStdStratItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResetStdStratItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteStdStrat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteStdStrat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStdStrat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStdStrat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportStdStratItemsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportStdStratItemsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ImportStdStratItemsByStream(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportStdStratItemsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItemsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportStdStratItemStatus, ::smart3dmap::v1::ImportedStdStratItem>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ImportStdStratItemsByStream(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ImportStdStratItemsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportStdStratItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportStdStratItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportStdStratItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportStdStratItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDicTableCategories() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDicTableCategories(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTableCategories(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTableCategories(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDicTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDicTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDicTableFields() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDicTableFields(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDicTableFields(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDicTableFields(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ConfigTableFieldMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConfigTableFieldMap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConfigTableFieldMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConfigTableFieldMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTablesInDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTablesInDB(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTablesInDB(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTablesInDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListFieldsOfTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListFieldsOfTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFieldsOfTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFieldsOfTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDataResourceTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDataResourceTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDataResourceTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDataResourceTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListMaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListMaps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMaps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLayersOfMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ListLayersOfMap(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ListLayersOfMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ListLayersOfMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLayersOfMapByPage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListLayersOfMapByPage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLayersOfMapByPage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLayersOfMapByPage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRasterLayerData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRasterLayerData(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRasterLayerData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRasterLayerData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteMap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListGeoSurveyProjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListGeoSurveyProjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGeoSurveyProjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGeoSurveyProjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGeoSurveyProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGeoSurveyProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetGeoSurveyProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetGeoSurveyProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDrillsByPage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDrillsByPage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDrillsByPage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDrillsByPage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDrillsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ListDrillsByStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ListDrillsByStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ListDrillsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDrill() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDrill(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrill(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrill(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDrillStdLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDrillOriginalLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDillLogs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDillLogs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListDillLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListDillLogs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListSectionMaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListSectionMaps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSectionMaps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSectionMaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListStructureModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListStructureModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStructureModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStructureModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListFieldModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListFieldModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFieldModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFieldModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExportModelMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExportModelMetadata(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportModelMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportModelMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportModelMetadata(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportModelMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateGeoSurveyProject() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateGeoSurveyProject(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGeoSurveyProject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGeoSurveyProject(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrillsByStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ImportDrillsByStream(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillsByStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::smart3dmap::v1::ImportDrillStatus, ::smart3dmap::v1::Drill>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ImportDrillsByStream(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ImportDrillsByStream(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrills() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportDrills(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrills(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrills(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportDrillOriginalLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDrillOriginalLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDrillOriginalLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillOriginalLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillOriginalLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportDrillStdLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDrillStdLayers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDrillStdLayers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillStdLayers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillStdLayers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrillWaterCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportDrillWaterCorrosivity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillWaterCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillWaterCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDrillWaterCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDrillWaterCorrosivity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillWaterCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillWaterCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportDrillSoilCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportDrillSoilCorrosivity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportDrillSoilCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportDrillSoilCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteDrillSoilCorrosivity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteDrillSoilCorrosivity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteDrillSoilCorrosivity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteDrillSoilCorrosivity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportGeotechnicalRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportGeotechnicalRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportGeotechnicalRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportGeotechnicalRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteGeotechnicalRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteGeotechnicalRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGeotechnicalRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGeotechnicalRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportStdPenetrationRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportStdPenetrationRecord(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportStdPenetrationRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportStdPenetrationRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteStdPenetrationRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteStdPenetrationRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStdPenetrationRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStdPenetrationRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportCompressiveResistanceRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportCompressiveResistanceRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportCompressiveResistanceRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportCompressiveResistanceRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteCompressiveResistanceRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteCompressiveResistanceRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCompressiveResistanceRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCompressiveResistanceRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDBServerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDBServerTypes() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDBServerTypesRequest, ::smart3dmap::v1::ListDBServerTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDBServerTypesRequest, ::smart3dmap::v1::ListDBServerTypesResponse>* streamer) {
                       return this->StreamedListDBServerTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDBServerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDBServerTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDBServerTypesRequest* /*request*/, ::smart3dmap::v1::ListDBServerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDBServerTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDBServerTypesRequest,::smart3dmap::v1::ListDBServerTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateDatabaseServer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::CreateDatabaseServerRequest, ::smart3dmap::v1::DBServer>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::CreateDatabaseServerRequest, ::smart3dmap::v1::DBServer>* streamer) {
                       return this->StreamedCreateDatabaseServer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateDatabaseServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::CreateDatabaseServerRequest,::smart3dmap::v1::DBServer>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDatabaseServers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDatabaseServers() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDatabaseServersRequest, ::smart3dmap::v1::ListDatabaseServersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDatabaseServersRequest, ::smart3dmap::v1::ListDatabaseServersResponse>* streamer) {
                       return this->StreamedListDatabaseServers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDatabaseServers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDatabaseServers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseServersRequest* /*request*/, ::smart3dmap::v1::ListDatabaseServersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDatabaseServers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDatabaseServersRequest,::smart3dmap::v1::ListDatabaseServersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDatabaseServer() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetDatabaseServerRequest, ::smart3dmap::v1::DBServer>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetDatabaseServerRequest, ::smart3dmap::v1::DBServer>* streamer) {
                       return this->StreamedGetDatabaseServer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DBServer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDatabaseServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetDatabaseServerRequest,::smart3dmap::v1::DBServer>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateDatabaseServer() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::UpdateDatabaseServerRequest, ::smart3dmap::v1::UpdateDatabaseServerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::UpdateDatabaseServerRequest, ::smart3dmap::v1::UpdateDatabaseServerResponse>* streamer) {
                       return this->StreamedUpdateDatabaseServer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateDatabaseServerRequest* /*request*/, ::smart3dmap::v1::UpdateDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateDatabaseServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::UpdateDatabaseServerRequest,::smart3dmap::v1::UpdateDatabaseServerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDatabaseServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDatabaseServer() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDatabaseServerRequest, ::smart3dmap::v1::DeleteDatabaseServerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDatabaseServerRequest, ::smart3dmap::v1::DeleteDatabaseServerResponse>* streamer) {
                       return this->StreamedDeleteDatabaseServer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDatabaseServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDatabaseServer(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseServerRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseServerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDatabaseServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDatabaseServerRequest,::smart3dmap::v1::DeleteDatabaseServerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDatabaseAppTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDatabaseAppTypes() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDatabaseAppTypesRequest, ::smart3dmap::v1::ListDatabaseAppTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDatabaseAppTypesRequest, ::smart3dmap::v1::ListDatabaseAppTypesResponse>* streamer) {
                       return this->StreamedListDatabaseAppTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDatabaseAppTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDatabaseAppTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabaseAppTypesRequest* /*request*/, ::smart3dmap::v1::ListDatabaseAppTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDatabaseAppTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDatabaseAppTypesRequest,::smart3dmap::v1::ListDatabaseAppTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateDatabase() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::CreateDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::CreateDatabaseRequest, ::smart3dmap::v1::Database>* streamer) {
                       return this->StreamedCreateDatabase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateDatabase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::CreateDatabaseRequest,::smart3dmap::v1::Database>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddExistingDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddExistingDatabase() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::AddExistingDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::AddExistingDatabaseRequest, ::smart3dmap::v1::Database>* streamer) {
                       return this->StreamedAddExistingDatabase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddExistingDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddExistingDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::AddExistingDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddExistingDatabase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::AddExistingDatabaseRequest,::smart3dmap::v1::Database>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDatabases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDatabases() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDatabasesRequest, ::smart3dmap::v1::ListDatabasesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDatabasesRequest, ::smart3dmap::v1::ListDatabasesResponse>* streamer) {
                       return this->StreamedListDatabases(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDatabases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDatabases(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDatabasesRequest* /*request*/, ::smart3dmap::v1::ListDatabasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDatabases(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDatabasesRequest,::smart3dmap::v1::ListDatabasesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDatabase() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetDatabaseRequest, ::smart3dmap::v1::Database>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetDatabaseRequest, ::smart3dmap::v1::Database>* streamer) {
                       return this->StreamedGetDatabase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDatabaseRequest* /*request*/, ::smart3dmap::v1::Database* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDatabase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetDatabaseRequest,::smart3dmap::v1::Database>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDatabase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDatabase() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDatabaseRequest, ::smart3dmap::v1::DeleteDatabaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDatabaseRequest, ::smart3dmap::v1::DeleteDatabaseResponse>* streamer) {
                       return this->StreamedDeleteDatabase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDatabase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDatabase(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDatabaseRequest* /*request*/, ::smart3dmap::v1::DeleteDatabaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDatabase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDatabaseRequest,::smart3dmap::v1::DeleteDatabaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListProjects() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListProjectsRequest, ::smart3dmap::v1::ListProjectsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListProjectsRequest, ::smart3dmap::v1::ListProjectsResponse>* streamer) {
                       return this->StreamedListProjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListProjectsRequest* /*request*/, ::smart3dmap::v1::ListProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListProjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListProjectsRequest,::smart3dmap::v1::ListProjectsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateProject() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::CreateProjectRequest, ::smart3dmap::v1::Project>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::CreateProjectRequest, ::smart3dmap::v1::Project>* streamer) {
                       return this->StreamedCreateProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::CreateProjectRequest,::smart3dmap::v1::Project>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProject() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetProjectRequest, ::smart3dmap::v1::Project>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetProjectRequest, ::smart3dmap::v1::Project>* streamer) {
                       return this->StreamedGetProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetProjectRequest* /*request*/, ::smart3dmap::v1::Project* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetProjectRequest,::smart3dmap::v1::Project>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateProject() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::UpdateProjectRequest, ::smart3dmap::v1::UpdateProjectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::UpdateProjectRequest, ::smart3dmap::v1::UpdateProjectResponse>* streamer) {
                       return this->StreamedUpdateProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateProjectRequest* /*request*/, ::smart3dmap::v1::UpdateProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::UpdateProjectRequest,::smart3dmap::v1::UpdateProjectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PublishProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PublishProject() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::PublishProjectRequest, ::smart3dmap::v1::PublishProjectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::PublishProjectRequest, ::smart3dmap::v1::PublishProjectResponse>* streamer) {
                       return this->StreamedPublishProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PublishProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PublishProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::PublishProjectRequest* /*request*/, ::smart3dmap::v1::PublishProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublishProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::PublishProjectRequest,::smart3dmap::v1::PublishProjectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteProject() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteProjectRequest, ::smart3dmap::v1::DeleteProjectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteProjectRequest, ::smart3dmap::v1::DeleteProjectResponse>* streamer) {
                       return this->StreamedDeleteProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteProjectRequest* /*request*/, ::smart3dmap::v1::DeleteProjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteProjectRequest,::smart3dmap::v1::DeleteProjectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateStdStrat() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::CreateStdStratRequest, ::smart3dmap::v1::StdStrat>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::CreateStdStratRequest, ::smart3dmap::v1::StdStrat>* streamer) {
                       return this->StreamedCreateStdStrat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::CreateStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateStdStrat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::CreateStdStratRequest,::smart3dmap::v1::StdStrat>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListStdStrats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListStdStrats() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListStdStratsRequest, ::smart3dmap::v1::ListStdStratsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListStdStratsRequest, ::smart3dmap::v1::ListStdStratsResponse>* streamer) {
                       return this->StreamedListStdStrats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListStdStrats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListStdStrats(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStdStratsRequest* /*request*/, ::smart3dmap::v1::ListStdStratsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListStdStrats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListStdStratsRequest,::smart3dmap::v1::ListStdStratsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStdStrat() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetStdStratRequest, ::smart3dmap::v1::StdStrat>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetStdStratRequest, ::smart3dmap::v1::StdStrat>* streamer) {
                       return this->StreamedGetStdStrat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetStdStratRequest* /*request*/, ::smart3dmap::v1::StdStrat* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStdStrat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetStdStratRequest,::smart3dmap::v1::StdStrat>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateStdStrat() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::UpdateStdStratRequest, ::smart3dmap::v1::UpdateStdStratResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::UpdateStdStratRequest, ::smart3dmap::v1::UpdateStdStratResponse>* streamer) {
                       return this->StreamedUpdateStdStrat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::UpdateStdStratRequest* /*request*/, ::smart3dmap::v1::UpdateStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateStdStrat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::UpdateStdStratRequest,::smart3dmap::v1::UpdateStdStratResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetStdStratItems() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ResetStdStratItemsRequest, ::smart3dmap::v1::ResetStdStratItemsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ResetStdStratItemsRequest, ::smart3dmap::v1::ResetStdStratItemsResponse>* streamer) {
                       return this->StreamedResetStdStratItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ResetStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ResetStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetStdStratItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ResetStdStratItemsRequest,::smart3dmap::v1::ResetStdStratItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteStdStrat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteStdStrat() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteStdStratRequest, ::smart3dmap::v1::DeleteStdStratResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteStdStratRequest, ::smart3dmap::v1::DeleteStdStratResponse>* streamer) {
                       return this->StreamedDeleteStdStrat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteStdStrat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteStdStrat(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteStdStratRequest* /*request*/, ::smart3dmap::v1::DeleteStdStratResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteStdStrat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteStdStratRequest,::smart3dmap::v1::DeleteStdStratResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportStdStratItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportStdStratItems() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportStdStratItemsRequest, ::smart3dmap::v1::ImportStdStratItemsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportStdStratItemsRequest, ::smart3dmap::v1::ImportStdStratItemsResponse>* streamer) {
                       return this->StreamedImportStdStratItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportStdStratItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportStdStratItems(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdStratItemsRequest* /*request*/, ::smart3dmap::v1::ImportStdStratItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportStdStratItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportStdStratItemsRequest,::smart3dmap::v1::ImportStdStratItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDicTableCategories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDicTableCategories() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDicTableCategoriesRequest, ::smart3dmap::v1::ListDicTableCategoriesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDicTableCategoriesRequest, ::smart3dmap::v1::ListDicTableCategoriesResponse>* streamer) {
                       return this->StreamedListDicTableCategories(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDicTableCategories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDicTableCategories(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableCategoriesRequest* /*request*/, ::smart3dmap::v1::ListDicTableCategoriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDicTableCategories(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDicTableCategoriesRequest,::smart3dmap::v1::ListDicTableCategoriesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDicTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDicTables() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDicTablesRequest, ::smart3dmap::v1::ListDicTablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDicTablesRequest, ::smart3dmap::v1::ListDicTablesResponse>* streamer) {
                       return this->StreamedListDicTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDicTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDicTables(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTablesRequest* /*request*/, ::smart3dmap::v1::ListDicTablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDicTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDicTablesRequest,::smart3dmap::v1::ListDicTablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDicTableFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDicTableFields() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDicTableFieldsRequest, ::smart3dmap::v1::ListDicTableFieldsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDicTableFieldsRequest, ::smart3dmap::v1::ListDicTableFieldsResponse>* streamer) {
                       return this->StreamedListDicTableFields(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDicTableFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDicTableFields(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDicTableFieldsRequest* /*request*/, ::smart3dmap::v1::ListDicTableFieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDicTableFields(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDicTableFieldsRequest,::smart3dmap::v1::ListDicTableFieldsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigTableFieldMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConfigTableFieldMap() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ConfigTableFieldMapRequest, ::smart3dmap::v1::ConfigTableFieldMapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ConfigTableFieldMapRequest, ::smart3dmap::v1::ConfigTableFieldMapResponse>* streamer) {
                       return this->StreamedConfigTableFieldMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConfigTableFieldMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigTableFieldMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ConfigTableFieldMapRequest* /*request*/, ::smart3dmap::v1::ConfigTableFieldMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigTableFieldMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ConfigTableFieldMapRequest,::smart3dmap::v1::ConfigTableFieldMapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTablesInDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTablesInDB() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListTablesInDBRequest, ::smart3dmap::v1::ListTablesInDBResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListTablesInDBRequest, ::smart3dmap::v1::ListTablesInDBResponse>* streamer) {
                       return this->StreamedListTablesInDB(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTablesInDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTablesInDB(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListTablesInDBRequest* /*request*/, ::smart3dmap::v1::ListTablesInDBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTablesInDB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListTablesInDBRequest,::smart3dmap::v1::ListTablesInDBResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListFieldsOfTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListFieldsOfTable() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListFieldsOfTableRequest, ::smart3dmap::v1::ListFieldsOfTableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListFieldsOfTableRequest, ::smart3dmap::v1::ListFieldsOfTableResponse>* streamer) {
                       return this->StreamedListFieldsOfTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListFieldsOfTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListFieldsOfTable(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldsOfTableRequest* /*request*/, ::smart3dmap::v1::ListFieldsOfTableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListFieldsOfTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListFieldsOfTableRequest,::smart3dmap::v1::ListFieldsOfTableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDataResourceTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDataResourceTypes() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDataResourceTypesRequest, ::smart3dmap::v1::ListDataResourceTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDataResourceTypesRequest, ::smart3dmap::v1::ListDataResourceTypesResponse>* streamer) {
                       return this->StreamedListDataResourceTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDataResourceTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDataResourceTypes(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDataResourceTypesRequest* /*request*/, ::smart3dmap::v1::ListDataResourceTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDataResourceTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDataResourceTypesRequest,::smart3dmap::v1::ListDataResourceTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListMaps() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListMapsRequest, ::smart3dmap::v1::ListMapsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListMapsRequest, ::smart3dmap::v1::ListMapsResponse>* streamer) {
                       return this->StreamedListMaps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListMapsRequest* /*request*/, ::smart3dmap::v1::ListMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMaps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListMapsRequest,::smart3dmap::v1::ListMapsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMap() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetMapRequest, ::smart3dmap::v1::Map>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetMapRequest, ::smart3dmap::v1::Map>* streamer) {
                       return this->StreamedGetMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetMapRequest* /*request*/, ::smart3dmap::v1::Map* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetMapRequest,::smart3dmap::v1::Map>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLayersOfMapByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListLayersOfMapByPage() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListLayersOfMapByPageRequest, ::smart3dmap::v1::ListLayersOfMapByPageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListLayersOfMapByPageRequest, ::smart3dmap::v1::ListLayersOfMapByPageResponse>* streamer) {
                       return this->StreamedListLayersOfMapByPage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListLayersOfMapByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLayersOfMapByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapByPageRequest* /*request*/, ::smart3dmap::v1::ListLayersOfMapByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLayersOfMapByPage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListLayersOfMapByPageRequest,::smart3dmap::v1::ListLayersOfMapByPageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRasterLayerData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRasterLayerData() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetRasterLayerDataRequest, ::smart3dmap::v1::RasterLayerData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetRasterLayerDataRequest, ::smart3dmap::v1::RasterLayerData>* streamer) {
                       return this->StreamedGetRasterLayerData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRasterLayerData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRasterLayerData(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetRasterLayerDataRequest* /*request*/, ::smart3dmap::v1::RasterLayerData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRasterLayerData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetRasterLayerDataRequest,::smart3dmap::v1::RasterLayerData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteMap() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteMapRequest, ::smart3dmap::v1::DeleteMapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteMapRequest, ::smart3dmap::v1::DeleteMapResponse>* streamer) {
                       return this->StreamedDeleteMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteMapRequest* /*request*/, ::smart3dmap::v1::DeleteMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteMapRequest,::smart3dmap::v1::DeleteMapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGeoSurveyProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListGeoSurveyProjects() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListGeoSurveyProjectsRequest, ::smart3dmap::v1::ListGeoSurveyProjectsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListGeoSurveyProjectsRequest, ::smart3dmap::v1::ListGeoSurveyProjectsResponse>* streamer) {
                       return this->StreamedListGeoSurveyProjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListGeoSurveyProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGeoSurveyProjects(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListGeoSurveyProjectsRequest* /*request*/, ::smart3dmap::v1::ListGeoSurveyProjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGeoSurveyProjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListGeoSurveyProjectsRequest,::smart3dmap::v1::ListGeoSurveyProjectsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGeoSurveyProject() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetGeoSurveyProjectRequest, ::smart3dmap::v1::GeoSurveyProject>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetGeoSurveyProjectRequest, ::smart3dmap::v1::GeoSurveyProject>* streamer) {
                       return this->StreamedGetGeoSurveyProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetGeoSurveyProjectRequest* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGeoSurveyProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetGeoSurveyProjectRequest,::smart3dmap::v1::GeoSurveyProject>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDrillsByPage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDrillsByPage() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDrillsByPageRequest, ::smart3dmap::v1::ListDrillsByPageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDrillsByPageRequest, ::smart3dmap::v1::ListDrillsByPageResponse>* streamer) {
                       return this->StreamedListDrillsByPage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDrillsByPage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDrillsByPage(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByPageRequest* /*request*/, ::smart3dmap::v1::ListDrillsByPageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDrillsByPage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDrillsByPageRequest,::smart3dmap::v1::ListDrillsByPageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDrill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDrill() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetDrillRequest, ::smart3dmap::v1::Drill>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetDrillRequest, ::smart3dmap::v1::Drill>* streamer) {
                       return this->StreamedGetDrill(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDrill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDrill(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillRequest* /*request*/, ::smart3dmap::v1::Drill* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDrill(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetDrillRequest,::smart3dmap::v1::Drill>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDrillStdLayers() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetDrillStdLayersRequest, ::smart3dmap::v1::DrillStdLayers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetDrillStdLayersRequest, ::smart3dmap::v1::DrillStdLayers>* streamer) {
                       return this->StreamedGetDrillStdLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillStdLayersRequest* /*request*/, ::smart3dmap::v1::DrillStdLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDrillStdLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetDrillStdLayersRequest,::smart3dmap::v1::DrillStdLayers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDrillOriginalLayers() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GetDrillDataRequest, ::smart3dmap::v1::DrillOriginalLayers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GetDrillDataRequest, ::smart3dmap::v1::DrillOriginalLayers>* streamer) {
                       return this->StreamedGetDrillOriginalLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GetDrillDataRequest* /*request*/, ::smart3dmap::v1::DrillOriginalLayers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GetDrillDataRequest,::smart3dmap::v1::DrillOriginalLayers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDillLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDillLogs() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListDrillLogsRequest, ::smart3dmap::v1::ListDrillLogsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListDrillLogsRequest, ::smart3dmap::v1::ListDrillLogsResponse>* streamer) {
                       return this->StreamedListDillLogs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDillLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDillLogs(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillLogsRequest* /*request*/, ::smart3dmap::v1::ListDrillLogsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDillLogs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListDrillLogsRequest,::smart3dmap::v1::ListDrillLogsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListSectionMaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListSectionMaps() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListSectionMapsRequest, ::smart3dmap::v1::ListSectionMapsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListSectionMapsRequest, ::smart3dmap::v1::ListSectionMapsResponse>* streamer) {
                       return this->StreamedListSectionMaps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListSectionMaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListSectionMaps(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListSectionMapsRequest* /*request*/, ::smart3dmap::v1::ListSectionMapsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListSectionMaps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListSectionMapsRequest,::smart3dmap::v1::ListSectionMapsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListStructureModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListStructureModels() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListStructureModelsRequest, ::smart3dmap::v1::ListStructureModelsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListStructureModelsRequest, ::smart3dmap::v1::ListStructureModelsResponse>* streamer) {
                       return this->StreamedListStructureModels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListStructureModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListStructureModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListStructureModelsRequest* /*request*/, ::smart3dmap::v1::ListStructureModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListStructureModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListStructureModelsRequest,::smart3dmap::v1::ListStructureModelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListFieldModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListFieldModels() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ListFieldModelsRequest, ::smart3dmap::v1::ListFieldModelsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ListFieldModelsRequest, ::smart3dmap::v1::ListFieldModelsResponse>* streamer) {
                       return this->StreamedListFieldModels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListFieldModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListFieldModels(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListFieldModelsRequest* /*request*/, ::smart3dmap::v1::ListFieldModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListFieldModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ListFieldModelsRequest,::smart3dmap::v1::ListFieldModelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteModel() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteModelRequest, ::smart3dmap::v1::DeleteModelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteModelRequest, ::smart3dmap::v1::DeleteModelResponse>* streamer) {
                       return this->StreamedDeleteModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteModelRequest* /*request*/, ::smart3dmap::v1::DeleteModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteModelRequest,::smart3dmap::v1::DeleteModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExportModelMetadata() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ExportModelMetadataRequest, ::smart3dmap::v1::ExportModelMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ExportModelMetadataRequest, ::smart3dmap::v1::ExportModelMetadataResponse>* streamer) {
                       return this->StreamedExportModelMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ExportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ExportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExportModelMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ExportModelMetadataRequest,::smart3dmap::v1::ExportModelMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportModelMetadata() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportModelMetadataRequest, ::smart3dmap::v1::ImportModelMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportModelMetadataRequest, ::smart3dmap::v1::ImportModelMetadataResponse>* streamer) {
                       return this->StreamedImportModelMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportModelMetadata(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportModelMetadataRequest* /*request*/, ::smart3dmap::v1::ImportModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportModelMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportModelMetadataRequest,::smart3dmap::v1::ImportModelMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateGeoSurveyProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateGeoSurveyProject() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::GeoSurveyProject, ::smart3dmap::v1::GeoSurveyProject>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::GeoSurveyProject, ::smart3dmap::v1::GeoSurveyProject>* streamer) {
                       return this->StreamedCreateGeoSurveyProject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateGeoSurveyProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateGeoSurveyProject(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::GeoSurveyProject* /*request*/, ::smart3dmap::v1::GeoSurveyProject* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateGeoSurveyProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::GeoSurveyProject,::smart3dmap::v1::GeoSurveyProject>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportDrills : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportDrills() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportDrillsRequest, ::smart3dmap::v1::ImportDrillsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportDrillsRequest, ::smart3dmap::v1::ImportDrillsResponse>* streamer) {
                       return this->StreamedImportDrills(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportDrills() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportDrills(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillsRequest* /*request*/, ::smart3dmap::v1::ImportDrillsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportDrills(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportDrillsRequest,::smart3dmap::v1::ImportDrillsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportDrillOriginalLayers() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DrillOriginalLayers, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DrillOriginalLayers, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportDrillOriginalLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillOriginalLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DrillOriginalLayers,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDrillOriginalLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDrillOriginalLayers() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteDrillOriginalLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDrillOriginalLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDrillOriginalLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDrillOriginalLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportDrillStdLayers() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DrillStdLayers, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DrillStdLayers, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportDrillStdLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DrillStdLayers* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportDrillStdLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DrillStdLayers,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDrillStdLayers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDrillStdLayers() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteDrillStdLayers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDrillStdLayers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDrillStdLayers(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDrillStdLayers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportDrillWaterCorrosivity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportDrillWaterCorrosivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportDrillWaterCorrosivityRequest,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDrillWaterCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDrillWaterCorrosivity() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteDrillWaterCorrosivity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDrillWaterCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDrillWaterCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDrillWaterCorrosivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportDrillSoilCorrosivity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportDrillSoilCorrosivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportDrillSoilCorrosivityRequest,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteDrillSoilCorrosivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteDrillSoilCorrosivity() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteDrillSoilCorrosivity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteDrillSoilCorrosivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteDrillSoilCorrosivity(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteDrillSoilCorrosivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportGeotechnicalRecords() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportGeotechnicalRecordsRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportGeotechnicalRecordsRequest, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportGeotechnicalRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportGeotechnicalRecordsRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportGeotechnicalRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportGeotechnicalRecordsRequest,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteGeotechnicalRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteGeotechnicalRecords() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteGeotechnicalRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteGeotechnicalRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteGeotechnicalRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteGeotechnicalRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportStdPenetrationRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportStdPenetrationRecord() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportStdPenetrationRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportStdPenetrationRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportStdPenetrationRecord(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportStdPenetrationRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportStdPenetrationRecord(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportStdPenetrationRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportStdPenetrationRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportStdPenetrationRecordRequest,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteStdPenetrationRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteStdPenetrationRecords() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteStdPenetrationRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteStdPenetrationRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteStdPenetrationRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteStdPenetrationRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest, ::smart3dmap::v1::ImportDrillDataStatus>* streamer) {
                       return this->StreamedImportCompressiveResistanceRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest* /*request*/, ::smart3dmap::v1::ImportDrillDataStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportCompressiveResistanceRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::ImportCompressiveResistanceRecordRequest,::smart3dmap::v1::ImportDrillDataStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteCompressiveResistanceRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteCompressiveResistanceRecords() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler<
          ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::smart3dmap::v1::DeleteDrillDataRequest, ::smart3dmap::v1::DeleteDrillDataResponse>* streamer) {
                       return this->StreamedDeleteCompressiveResistanceRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteCompressiveResistanceRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteCompressiveResistanceRecords(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::DeleteDrillDataRequest* /*request*/, ::smart3dmap::v1::DeleteDrillDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteCompressiveResistanceRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::smart3dmap::v1::DeleteDrillDataRequest,::smart3dmap::v1::DeleteDrillDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListDBServerTypes<WithStreamedUnaryMethod_CreateDatabaseServer<WithStreamedUnaryMethod_ListDatabaseServers<WithStreamedUnaryMethod_GetDatabaseServer<WithStreamedUnaryMethod_UpdateDatabaseServer<WithStreamedUnaryMethod_DeleteDatabaseServer<WithStreamedUnaryMethod_ListDatabaseAppTypes<WithStreamedUnaryMethod_CreateDatabase<WithStreamedUnaryMethod_AddExistingDatabase<WithStreamedUnaryMethod_ListDatabases<WithStreamedUnaryMethod_GetDatabase<WithStreamedUnaryMethod_DeleteDatabase<WithStreamedUnaryMethod_ListProjects<WithStreamedUnaryMethod_CreateProject<WithStreamedUnaryMethod_GetProject<WithStreamedUnaryMethod_UpdateProject<WithStreamedUnaryMethod_PublishProject<WithStreamedUnaryMethod_DeleteProject<WithStreamedUnaryMethod_CreateStdStrat<WithStreamedUnaryMethod_ListStdStrats<WithStreamedUnaryMethod_GetStdStrat<WithStreamedUnaryMethod_UpdateStdStrat<WithStreamedUnaryMethod_ResetStdStratItems<WithStreamedUnaryMethod_DeleteStdStrat<WithStreamedUnaryMethod_ImportStdStratItems<WithStreamedUnaryMethod_ListDicTableCategories<WithStreamedUnaryMethod_ListDicTables<WithStreamedUnaryMethod_ListDicTableFields<WithStreamedUnaryMethod_ConfigTableFieldMap<WithStreamedUnaryMethod_ListTablesInDB<WithStreamedUnaryMethod_ListFieldsOfTable<WithStreamedUnaryMethod_ListDataResourceTypes<WithStreamedUnaryMethod_ListMaps<WithStreamedUnaryMethod_GetMap<WithStreamedUnaryMethod_ListLayersOfMapByPage<WithStreamedUnaryMethod_GetRasterLayerData<WithStreamedUnaryMethod_DeleteMap<WithStreamedUnaryMethod_ListGeoSurveyProjects<WithStreamedUnaryMethod_GetGeoSurveyProject<WithStreamedUnaryMethod_ListDrillsByPage<WithStreamedUnaryMethod_GetDrill<WithStreamedUnaryMethod_GetDrillStdLayers<WithStreamedUnaryMethod_GetDrillOriginalLayers<WithStreamedUnaryMethod_ListDillLogs<WithStreamedUnaryMethod_ListSectionMaps<WithStreamedUnaryMethod_ListStructureModels<WithStreamedUnaryMethod_ListFieldModels<WithStreamedUnaryMethod_DeleteModel<WithStreamedUnaryMethod_ExportModelMetadata<WithStreamedUnaryMethod_ImportModelMetadata<WithStreamedUnaryMethod_CreateGeoSurveyProject<WithStreamedUnaryMethod_ImportDrills<WithStreamedUnaryMethod_ImportDrillOriginalLayers<WithStreamedUnaryMethod_DeleteDrillOriginalLayers<WithStreamedUnaryMethod_ImportDrillStdLayers<WithStreamedUnaryMethod_DeleteDrillStdLayers<WithStreamedUnaryMethod_ImportDrillWaterCorrosivity<WithStreamedUnaryMethod_DeleteDrillWaterCorrosivity<WithStreamedUnaryMethod_ImportDrillSoilCorrosivity<WithStreamedUnaryMethod_DeleteDrillSoilCorrosivity<WithStreamedUnaryMethod_ImportGeotechnicalRecords<WithStreamedUnaryMethod_DeleteGeotechnicalRecords<WithStreamedUnaryMethod_ImportStdPenetrationRecord<WithStreamedUnaryMethod_DeleteStdPenetrationRecords<WithStreamedUnaryMethod_ImportCompressiveResistanceRecords<WithStreamedUnaryMethod_DeleteCompressiveResistanceRecords<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_ListLayersOfMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ListLayersOfMap() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::smart3dmap::v1::ListLayersOfMapRequest, ::smart3dmap::v1::Layer>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::smart3dmap::v1::ListLayersOfMapRequest, ::smart3dmap::v1::Layer>* streamer) {
                       return this->StreamedListLayersOfMap(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ListLayersOfMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLayersOfMap(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListLayersOfMapRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Layer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedListLayersOfMap(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::smart3dmap::v1::ListLayersOfMapRequest,::smart3dmap::v1::Layer>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ListDrillsByStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ListDrillsByStream() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::smart3dmap::v1::ListDrillsByStreamRequest, ::smart3dmap::v1::Drill>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::smart3dmap::v1::ListDrillsByStreamRequest, ::smart3dmap::v1::Drill>* streamer) {
                       return this->StreamedListDrillsByStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ListDrillsByStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDrillsByStream(::grpc::ServerContext* /*context*/, const ::smart3dmap::v1::ListDrillsByStreamRequest* /*request*/, ::grpc::ServerWriter< ::smart3dmap::v1::Drill>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedListDrillsByStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::smart3dmap::v1::ListDrillsByStreamRequest,::smart3dmap::v1::Drill>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_ListLayersOfMap<WithSplitStreamingMethod_ListDrillsByStream<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListDBServerTypes<WithStreamedUnaryMethod_CreateDatabaseServer<WithStreamedUnaryMethod_ListDatabaseServers<WithStreamedUnaryMethod_GetDatabaseServer<WithStreamedUnaryMethod_UpdateDatabaseServer<WithStreamedUnaryMethod_DeleteDatabaseServer<WithStreamedUnaryMethod_ListDatabaseAppTypes<WithStreamedUnaryMethod_CreateDatabase<WithStreamedUnaryMethod_AddExistingDatabase<WithStreamedUnaryMethod_ListDatabases<WithStreamedUnaryMethod_GetDatabase<WithStreamedUnaryMethod_DeleteDatabase<WithStreamedUnaryMethod_ListProjects<WithStreamedUnaryMethod_CreateProject<WithStreamedUnaryMethod_GetProject<WithStreamedUnaryMethod_UpdateProject<WithStreamedUnaryMethod_PublishProject<WithStreamedUnaryMethod_DeleteProject<WithStreamedUnaryMethod_CreateStdStrat<WithStreamedUnaryMethod_ListStdStrats<WithStreamedUnaryMethod_GetStdStrat<WithStreamedUnaryMethod_UpdateStdStrat<WithStreamedUnaryMethod_ResetStdStratItems<WithStreamedUnaryMethod_DeleteStdStrat<WithStreamedUnaryMethod_ImportStdStratItems<WithStreamedUnaryMethod_ListDicTableCategories<WithStreamedUnaryMethod_ListDicTables<WithStreamedUnaryMethod_ListDicTableFields<WithStreamedUnaryMethod_ConfigTableFieldMap<WithStreamedUnaryMethod_ListTablesInDB<WithStreamedUnaryMethod_ListFieldsOfTable<WithStreamedUnaryMethod_ListDataResourceTypes<WithStreamedUnaryMethod_ListMaps<WithStreamedUnaryMethod_GetMap<WithSplitStreamingMethod_ListLayersOfMap<WithStreamedUnaryMethod_ListLayersOfMapByPage<WithStreamedUnaryMethod_GetRasterLayerData<WithStreamedUnaryMethod_DeleteMap<WithStreamedUnaryMethod_ListGeoSurveyProjects<WithStreamedUnaryMethod_GetGeoSurveyProject<WithStreamedUnaryMethod_ListDrillsByPage<WithSplitStreamingMethod_ListDrillsByStream<WithStreamedUnaryMethod_GetDrill<WithStreamedUnaryMethod_GetDrillStdLayers<WithStreamedUnaryMethod_GetDrillOriginalLayers<WithStreamedUnaryMethod_ListDillLogs<WithStreamedUnaryMethod_ListSectionMaps<WithStreamedUnaryMethod_ListStructureModels<WithStreamedUnaryMethod_ListFieldModels<WithStreamedUnaryMethod_DeleteModel<WithStreamedUnaryMethod_ExportModelMetadata<WithStreamedUnaryMethod_ImportModelMetadata<WithStreamedUnaryMethod_CreateGeoSurveyProject<WithStreamedUnaryMethod_ImportDrills<WithStreamedUnaryMethod_ImportDrillOriginalLayers<WithStreamedUnaryMethod_DeleteDrillOriginalLayers<WithStreamedUnaryMethod_ImportDrillStdLayers<WithStreamedUnaryMethod_DeleteDrillStdLayers<WithStreamedUnaryMethod_ImportDrillWaterCorrosivity<WithStreamedUnaryMethod_DeleteDrillWaterCorrosivity<WithStreamedUnaryMethod_ImportDrillSoilCorrosivity<WithStreamedUnaryMethod_DeleteDrillSoilCorrosivity<WithStreamedUnaryMethod_ImportGeotechnicalRecords<WithStreamedUnaryMethod_DeleteGeotechnicalRecords<WithStreamedUnaryMethod_ImportStdPenetrationRecord<WithStreamedUnaryMethod_DeleteStdPenetrationRecords<WithStreamedUnaryMethod_ImportCompressiveResistanceRecords<WithStreamedUnaryMethod_DeleteCompressiveResistanceRecords<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace smart3dmap


#endif  // GRPC_data_5fengine_2fdata_5fengine_2eproto__INCLUDED
